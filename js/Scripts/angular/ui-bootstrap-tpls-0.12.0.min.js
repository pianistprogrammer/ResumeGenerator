///*
// * angular-ui-bootstrap
// * http://angular-ui.github.io/bootstrap/

// * Version: 0.13.0 - 2015-05-02
// * License: MIT
// */
//angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.bindHtml", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.position", "ui.bootstrap.datepicker", "ui.bootstrap.dropdown", "ui.bootstrap.modal", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.transition", "ui.bootstrap.typeahead"]), angular.module("ui.bootstrap.tpls", ["template/accordion/accordion-group.html", "template/accordion/accordion.html", "template/alert/alert.html", "template/carousel/carousel.html", "template/carousel/slide.html", "template/datepicker/datepicker.html", "template/datepicker/day.html", "template/datepicker/month.html", "template/datepicker/popup.html", "template/datepicker/year.html", "template/modal/backdrop.html", "template/modal/window.html", "template/pagination/pager.html", "template/pagination/pagination.html", "template/tooltip/tooltip-html-popup.html", "template/tooltip/tooltip-html-unsafe-popup.html", "template/tooltip/tooltip-popup.html", "template/tooltip/tooltip-template-popup.html", "template/popover/popover-template.html", "template/popover/popover.html", "template/progressbar/bar.html", "template/progressbar/progress.html", "template/progressbar/progressbar.html", "template/rating/rating.html", "template/tabs/tab.html", "template/tabs/tabset.html", "template/timepicker/timepicker.html", "template/typeahead/typeahead-match.html", "template/typeahead/typeahead-popup.html"]), angular.module("ui.bootstrap.collapse", []).directive("collapse", ["$animate", function (a) { return { link: function (b, c, d) { function e() { c.removeClass("collapse").addClass("collapsing"), a.addClass(c, "in", { to: { height: c[0].scrollHeight + "px" } }).then(f) } function f() { c.removeClass("collapsing"), c.css({ height: "auto" }) } function g() { c.css({ height: c[0].scrollHeight + "px" }).removeClass("collapse").addClass("collapsing"), a.removeClass(c, "in", { to: { height: "0" } }).then(h) } function h() { c.css({ height: "0" }), c.removeClass("collapsing"), c.addClass("collapse") } b.$watch(d.collapse, function (a) { a ? g() : e() }) } } }]), angular.module("ui.bootstrap.accordion", ["ui.bootstrap.collapse"]).constant("accordionConfig", { closeOthers: !0 }).controller("AccordionController", ["$scope", "$attrs", "accordionConfig", function (a, b, c) { this.groups = [], this.closeOthers = function (d) { var e = angular.isDefined(b.closeOthers) ? a.$eval(b.closeOthers) : c.closeOthers; e && angular.forEach(this.groups, function (a) { a !== d && (a.isOpen = !1) }) }, this.addGroup = function (a) { var b = this; this.groups.push(a), a.$on("$destroy", function () { b.removeGroup(a) }) }, this.removeGroup = function (a) { var b = this.groups.indexOf(a); -1 !== b && this.groups.splice(b, 1) } }]).directive("accordion", function () { return { restrict: "EA", controller: "AccordionController", transclude: !0, replace: !1, templateUrl: "template/accordion/accordion.html" } }).directive("accordionGroup", function () { return { require: "^accordion", restrict: "EA", transclude: !0, replace: !0, templateUrl: "template/accordion/accordion-group.html", scope: { heading: "@", isOpen: "=?", isDisabled: "=?" }, controller: function () { this.setHeading = function (a) { this.heading = a } }, link: function (a, b, c, d) { d.addGroup(a), a.$watch("isOpen", function (b) { b && d.closeOthers(a) }), a.toggleOpen = function () { a.isDisabled || (a.isOpen = !a.isOpen) } } } }).directive("accordionHeading", function () { return { restrict: "EA", transclude: !0, template: "", replace: !0, require: "^accordionGroup", link: function (a, b, c, d, e) { d.setHeading(e(a, angular.noop)) } } }).directive("accordionTransclude", function () { return { require: "^accordionGroup", link: function (a, b, c, d) { a.$watch(function () { return d[c.accordionTransclude] }, function (a) { a && (b.html(""), b.append(a)) }) } } }), angular.module("ui.bootstrap.alert", []).controller("AlertController", ["$scope", "$attrs", function (a, b) { a.closeable = "close" in b, this.close = a.close }]).directive("alert", function () { return { restrict: "EA", controller: "AlertController", templateUrl: "template/alert/alert.html", transclude: !0, replace: !0, scope: { type: "@", close: "&" } } }).directive("dismissOnTimeout", ["$timeout", function (a) { return { require: "alert", link: function (b, c, d, e) { a(function () { e.close() }, parseInt(d.dismissOnTimeout, 10)) } } }]), angular.module("ui.bootstrap.bindHtml", []).directive("bindHtmlUnsafe", function () { return function (a, b, c) { b.addClass("ng-binding").data("$binding", c.bindHtmlUnsafe), a.$watch(c.bindHtmlUnsafe, function (a) { b.html(a || "") }) } }), angular.module("ui.bootstrap.buttons", []).constant("buttonConfig", { activeClass: "active", toggleEvent: "click" }).controller("ButtonsController", ["buttonConfig", function (a) { this.activeClass = a.activeClass || "active", this.toggleEvent = a.toggleEvent || "click" }]).directive("btnRadio", function () { return { require: ["btnRadio", "ngModel"], controller: "ButtonsController", link: function (a, b, c, d) { var e = d[0], f = d[1]; f.$render = function () { b.toggleClass(e.activeClass, angular.equals(f.$modelValue, a.$eval(c.btnRadio))) }, b.bind(e.toggleEvent, function () { var d = b.hasClass(e.activeClass); (!d || angular.isDefined(c.uncheckable)) && a.$apply(function () { f.$setViewValue(d ? null : a.$eval(c.btnRadio)), f.$render() }) }) } } }).directive("btnCheckbox", function () { return { require: ["btnCheckbox", "ngModel"], controller: "ButtonsController", link: function (a, b, c, d) { function e() { return g(c.btnCheckboxTrue, !0) } function f() { return g(c.btnCheckboxFalse, !1) } function g(b, c) { var d = a.$eval(b); return angular.isDefined(d) ? d : c } var h = d[0], i = d[1]; i.$render = function () { b.toggleClass(h.activeClass, angular.equals(i.$modelValue, e())) }, b.bind(h.toggleEvent, function () { a.$apply(function () { i.$setViewValue(b.hasClass(h.activeClass) ? f() : e()), i.$render() }) }) } } }), angular.module("ui.bootstrap.carousel", []).controller("CarouselController", ["$scope", "$interval", "$animate", function (a, b, c) { function d(a) { if (angular.isUndefined(k[a].index)) return k[a]; { var b; k.length } for (b = 0; b < k.length; ++b) if (k[b].index == a) return k[b] } function e() { f(); var c = +a.interval; !isNaN(c) && c > 0 && (h = b(g, c)) } function f() { h && (b.cancel(h), h = null) } function g() { var b = +a.interval; i && !isNaN(b) && b > 0 ? a.next() : a.pause() } var h, i, j = this, k = j.slides = a.slides = [], l = -1; j.currentSlide = null; var m = !1; j.select = a.select = function (b, d) { function f() { m || (angular.extend(b, { direction: d, active: !0 }), angular.extend(j.currentSlide || {}, { direction: d, active: !1 }), c.enabled() && !a.noTransition && b.$element && (a.$currentTransition = !0, b.$element.one("$animate:close", function () { a.$currentTransition = null })), j.currentSlide = b, l = g, e()) } var g = j.indexOfSlide(b); void 0 === d && (d = g > j.getCurrentIndex() ? "next" : "prev"), b && b !== j.currentSlide && f() }, a.$on("$destroy", function () { m = !0 }), j.getCurrentIndex = function () { return j.currentSlide && angular.isDefined(j.currentSlide.index) ? +j.currentSlide.index : l }, j.indexOfSlide = function (a) { return angular.isDefined(a.index) ? +a.index : k.indexOf(a) }, a.next = function () { var b = (j.getCurrentIndex() + 1) % k.length; return a.$currentTransition ? void 0 : j.select(d(b), "next") }, a.prev = function () { var b = j.getCurrentIndex() - 1 < 0 ? k.length - 1 : j.getCurrentIndex() - 1; return a.$currentTransition ? void 0 : j.select(d(b), "prev") }, a.isActive = function (a) { return j.currentSlide === a }, a.$watch("interval", e), a.$on("$destroy", f), a.play = function () { i || (i = !0, e()) }, a.pause = function () { a.noPause || (i = !1, f()) }, j.addSlide = function (b, c) { b.$element = c, k.push(b), 1 === k.length || b.active ? (j.select(k[k.length - 1]), 1 == k.length && a.play()) : b.active = !1 }, j.removeSlide = function (a) { angular.isDefined(a.index) && k.sort(function (a, b) { return +a.index > +b.index }); var b = k.indexOf(a); k.splice(b, 1), k.length > 0 && a.active ? j.select(b >= k.length ? k[b - 1] : k[b]) : l > b && l-- } }]).directive("carousel", [function () { return { restrict: "EA", transclude: !0, replace: !0, controller: "CarouselController", require: "carousel", templateUrl: "template/carousel/carousel.html", scope: { interval: "=", noTransition: "=", noPause: "=" } } }]).directive("slide", function () { return { require: "^carousel", restrict: "EA", transclude: !0, replace: !0, templateUrl: "template/carousel/slide.html", scope: { active: "=?", index: "=?" }, link: function (a, b, c, d) { d.addSlide(a, b), a.$on("$destroy", function () { d.removeSlide(a) }), a.$watch("active", function (b) { b && d.select(a) }) } } }).animation(".item", ["$animate", function (a) { return { beforeAddClass: function (b, c, d) { if ("active" == c && b.parent() && !b.parent().scope().noTransition) { var e = !1, f = b.isolateScope().direction, g = "next" == f ? "left" : "right"; return b.addClass(f), a.addClass(b, g).then(function () { e || b.removeClass(g + " " + f), d() }), function () { e = !0 } } d() }, beforeRemoveClass: function (b, c, d) { if ("active" == c && b.parent() && !b.parent().scope().noTransition) { var e = !1, f = b.isolateScope().direction, g = "next" == f ? "left" : "right"; return a.addClass(b, g).then(function () { e || b.removeClass(g), d() }), function () { e = !0 } } d() } } }]), angular.module("ui.bootstrap.dateparser", []).service("dateParser", ["$locale", "orderByFilter", function (a, b) { function c(a) { var c = [], d = a.split(""); return angular.forEach(f, function (b, e) { var f = a.indexOf(e); if (f > -1) { a = a.split(""), d[f] = "(" + b.regex + ")", a[f] = "$"; for (var g = f + 1, h = f + e.length; h > g; g++) d[g] = "", a[g] = "$"; a = a.join(""), c.push({ index: f, apply: b.apply }) } }), { regex: new RegExp("^" + d.join("") + "$"), map: b(c, "index") } } function d(a, b, c) { return 1 > c ? !1 : 1 === b && c > 28 ? 29 === c && (a % 4 === 0 && a % 100 !== 0 || a % 400 === 0) : 3 === b || 5 === b || 8 === b || 10 === b ? 31 > c : !0 } var e = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g; this.parsers = {}; var f = { yyyy: { regex: "\\d{4}", apply: function (a) { this.year = +a } }, yy: { regex: "\\d{2}", apply: function (a) { this.year = +a + 2e3 } }, y: { regex: "\\d{1,4}", apply: function (a) { this.year = +a } }, MMMM: { regex: a.DATETIME_FORMATS.MONTH.join("|"), apply: function (b) { this.month = a.DATETIME_FORMATS.MONTH.indexOf(b) } }, MMM: { regex: a.DATETIME_FORMATS.SHORTMONTH.join("|"), apply: function (b) { this.month = a.DATETIME_FORMATS.SHORTMONTH.indexOf(b) } }, MM: { regex: "0[1-9]|1[0-2]", apply: function (a) { this.month = a - 1 } }, M: { regex: "[1-9]|1[0-2]", apply: function (a) { this.month = a - 1 } }, dd: { regex: "[0-2][0-9]{1}|3[0-1]{1}", apply: function (a) { this.date = +a } }, d: { regex: "[1-2]?[0-9]{1}|3[0-1]{1}", apply: function (a) { this.date = +a } }, EEEE: { regex: a.DATETIME_FORMATS.DAY.join("|") }, EEE: { regex: a.DATETIME_FORMATS.SHORTDAY.join("|") }, HH: { regex: "(?:0|1)[0-9]|2[0-3]", apply: function (a) { this.hours = +a } }, H: { regex: "1?[0-9]|2[0-3]", apply: function (a) { this.hours = +a } }, mm: { regex: "[0-5][0-9]", apply: function (a) { this.minutes = +a } }, m: { regex: "[0-9]|[1-5][0-9]", apply: function (a) { this.minutes = +a } }, sss: { regex: "[0-9][0-9][0-9]", apply: function (a) { this.milliseconds = +a } }, ss: { regex: "[0-5][0-9]", apply: function (a) { this.seconds = +a } }, s: { regex: "[0-9]|[1-5][0-9]", apply: function (a) { this.seconds = +a } } }; this.parse = function (b, f, g) { if (!angular.isString(b) || !f) return b; f = a.DATETIME_FORMATS[f] || f, f = f.replace(e, "\\$&"), this.parsers[f] || (this.parsers[f] = c(f)); var h = this.parsers[f], i = h.regex, j = h.map, k = b.match(i); if (k && k.length) { var l, m; l = g ? { year: g.getFullYear(), month: g.getMonth(), date: g.getDate(), hours: g.getHours(), minutes: g.getMinutes(), seconds: g.getSeconds(), milliseconds: g.getMilliseconds() } : { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 }; for (var n = 1, o = k.length; o > n; n++) { var p = j[n - 1]; p.apply && p.apply.call(l, k[n]) } return d(l.year, l.month, l.date) && (m = new Date(l.year, l.month, l.date, l.hours, l.minutes, l.seconds, l.milliseconds || 0)), m } } }]), angular.module("ui.bootstrap.position", []).factory("$position", ["$document", "$window", function (a, b) { function c(a, c) { return a.currentStyle ? a.currentStyle[c] : b.getComputedStyle ? b.getComputedStyle(a)[c] : a.style[c] } function d(a) { return "static" === (c(a, "position") || "static") } var e = function (b) { for (var c = a[0], e = b.offsetParent || c; e && e !== c && d(e) ;) e = e.offsetParent; return e || c }; return { position: function (b) { var c = this.offset(b), d = { top: 0, left: 0 }, f = e(b[0]); f != a[0] && (d = this.offset(angular.element(f)), d.top += f.clientTop - f.scrollTop, d.left += f.clientLeft - f.scrollLeft); var g = b[0].getBoundingClientRect(); return { width: g.width || b.prop("offsetWidth"), height: g.height || b.prop("offsetHeight"), top: c.top - d.top, left: c.left - d.left } }, offset: function (c) { var d = c[0].getBoundingClientRect(); return { width: d.width || c.prop("offsetWidth"), height: d.height || c.prop("offsetHeight"), top: d.top + (b.pageYOffset || a[0].documentElement.scrollTop), left: d.left + (b.pageXOffset || a[0].documentElement.scrollLeft) } }, positionElements: function (a, b, c, d) { var e, f, g, h, i = c.split("-"), j = i[0], k = i[1] || "center"; e = d ? this.offset(a) : this.position(a), f = b.prop("offsetWidth"), g = b.prop("offsetHeight"); var l = { center: function () { return e.left + e.width / 2 - f / 2 }, left: function () { return e.left }, right: function () { return e.left + e.width } }, m = { center: function () { return e.top + e.height / 2 - g / 2 }, top: function () { return e.top }, bottom: function () { return e.top + e.height } }; switch (j) { case "right": h = { top: m[k](), left: l[j]() }; break; case "left": h = { top: m[k](), left: e.left - f }; break; case "bottom": h = { top: m[j](), left: l[k]() }; break; default: h = { top: e.top - g, left: l[k]() } } return h } } }]), angular.module("ui.bootstrap.datepicker", ["ui.bootstrap.dateparser", "ui.bootstrap.position"]).constant("datepickerConfig", { formatDay: "dd", formatMonth: "MMMM", formatYear: "yyyy", formatDayHeader: "EEE", formatDayTitle: "MMMM yyyy", formatMonthTitle: "yyyy", datepickerMode: "day", minMode: "day", maxMode: "year", showWeeks: !0, startingDay: 0, yearRange: 20, minDate: null, maxDate: null, shortcutPropagation: !1 }).controller("DatepickerController", ["$scope", "$attrs", "$parse", "$interpolate", "$timeout", "$log", "dateFilter", "datepickerConfig", function (a, b, c, d, e, f, g, h) { var i = this, j = { $setViewValue: angular.noop }; this.modes = ["day", "month", "year"], angular.forEach(["formatDay", "formatMonth", "formatYear", "formatDayHeader", "formatDayTitle", "formatMonthTitle", "minMode", "maxMode", "showWeeks", "startingDay", "yearRange", "shortcutPropagation"], function (c, e) { i[c] = angular.isDefined(b[c]) ? 8 > e ? d(b[c])(a.$parent) : a.$parent.$eval(b[c]) : h[c] }), angular.forEach(["minDate", "maxDate"], function (d) { b[d] ? a.$parent.$watch(c(b[d]), function (a) { i[d] = a ? new Date(a) : null, i.refreshView() }) : i[d] = h[d] ? new Date(h[d]) : null }), a.datepickerMode = a.datepickerMode || h.datepickerMode, a.maxMode = i.maxMode, a.uniqueId = "datepicker-" + a.$id + "-" + Math.floor(1e4 * Math.random()), angular.isDefined(b.initDate) ? (this.activeDate = a.$parent.$eval(b.initDate) || new Date, a.$parent.$watch(b.initDate, function (a) { a && (j.$isEmpty(j.$modelValue) || j.$invalid) && (i.activeDate = a, i.refreshView()) })) : this.activeDate = new Date, a.isActive = function (b) { return 0 === i.compare(b.date, i.activeDate) ? (a.activeDateId = b.uid, !0) : !1 }, this.init = function (a) { j = a, j.$render = function () { i.render() } }, this.render = function () { if (j.$viewValue) { var a = new Date(j.$viewValue), b = !isNaN(a); b ? this.activeDate = a : f.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.'), j.$setValidity("date", b) } this.refreshView() }, this.refreshView = function () { if (this.element) { this._refreshView(); var a = j.$viewValue ? new Date(j.$viewValue) : null; j.$setValidity("date-disabled", !a || this.element && !this.isDisabled(a)) } }, this.createDateObject = function (a, b) { var c = j.$viewValue ? new Date(j.$viewValue) : null; return { date: a, label: g(a, b), selected: c && 0 === this.compare(a, c), disabled: this.isDisabled(a), current: 0 === this.compare(a, new Date), customClass: this.customClass(a) } }, this.isDisabled = function (c) { return this.minDate && this.compare(c, this.minDate) < 0 || this.maxDate && this.compare(c, this.maxDate) > 0 || b.dateDisabled && a.dateDisabled({ date: c, mode: a.datepickerMode }) }, this.customClass = function (b) { return a.customClass({ date: b, mode: a.datepickerMode }) }, this.split = function (a, b) { for (var c = []; a.length > 0;) c.push(a.splice(0, b)); return c }, a.select = function (b) { if (a.datepickerMode === i.minMode) { var c = j.$viewValue ? new Date(j.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0); c.setFullYear(b.getFullYear(), b.getMonth(), b.getDate()), j.$setViewValue(c), j.$render() } else i.activeDate = b, a.datepickerMode = i.modes[i.modes.indexOf(a.datepickerMode) - 1] }, a.move = function (a) { var b = i.activeDate.getFullYear() + a * (i.step.years || 0), c = i.activeDate.getMonth() + a * (i.step.months || 0); i.activeDate.setFullYear(b, c, 1), i.refreshView() }, a.toggleMode = function (b) { b = b || 1, a.datepickerMode === i.maxMode && 1 === b || a.datepickerMode === i.minMode && -1 === b || (a.datepickerMode = i.modes[i.modes.indexOf(a.datepickerMode) + b]) }, a.keys = { 13: "enter", 32: "space", 33: "pageup", 34: "pagedown", 35: "end", 36: "home", 37: "left", 38: "up", 39: "right", 40: "down" }; var k = function () { e(function () { i.element[0].focus() }, 0, !1) }; a.$on("datepicker.focus", k), a.keydown = function (b) { var c = a.keys[b.which]; if (c && !b.shiftKey && !b.altKey) if (b.preventDefault(), i.shortcutPropagation || b.stopPropagation(), "enter" === c || "space" === c) { if (i.isDisabled(i.activeDate)) return; a.select(i.activeDate), k() } else !b.ctrlKey || "up" !== c && "down" !== c ? (i.handleKeyDown(c, b), i.refreshView()) : (a.toggleMode("up" === c ? 1 : -1), k()) } }]).directive("datepicker", function () { return { restrict: "EA", replace: !0, templateUrl: "template/datepicker/datepicker.html", scope: { datepickerMode: "=?", dateDisabled: "&", customClass: "&", shortcutPropagation: "&?" }, require: ["datepicker", "?^ngModel"], controller: "DatepickerController", link: function (a, b, c, d) { var e = d[0], f = d[1]; f && e.init(f) } } }).directive("daypicker", ["dateFilter", function (a) { return { restrict: "EA", replace: !0, templateUrl: "template/datepicker/day.html", require: "^datepicker", link: function (b, c, d, e) { function f(a, b) { return 1 !== b || a % 4 !== 0 || a % 100 === 0 && a % 400 !== 0 ? i[b] : 29 } function g(a, b) { var c = new Array(b), d = new Date(a), e = 0; for (d.setHours(12) ; b > e;) c[e++] = new Date(d), d.setDate(d.getDate() + 1); return c } function h(a) { var b = new Date(a); b.setDate(b.getDate() + 4 - (b.getDay() || 7)); var c = b.getTime(); return b.setMonth(0), b.setDate(1), Math.floor(Math.round((c - b) / 864e5) / 7) + 1 } b.showWeeks = e.showWeeks, e.step = { months: 1 }, e.element = c; var i = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; e._refreshView = function () { var c = e.activeDate.getFullYear(), d = e.activeDate.getMonth(), f = new Date(c, d, 1), i = e.startingDay - f.getDay(), j = i > 0 ? 7 - i : -i, k = new Date(f); j > 0 && k.setDate(-j + 1); for (var l = g(k, 42), m = 0; 42 > m; m++) l[m] = angular.extend(e.createDateObject(l[m], e.formatDay), { secondary: l[m].getMonth() !== d, uid: b.uniqueId + "-" + m }); b.labels = new Array(7); for (var n = 0; 7 > n; n++) b.labels[n] = { abbr: a(l[n].date, e.formatDayHeader), full: a(l[n].date, "EEEE") }; if (b.title = a(e.activeDate, e.formatDayTitle), b.rows = e.split(l, 7), b.showWeeks) { b.weekNumbers = []; for (var o = (11 - e.startingDay) % 7, p = b.rows.length, q = 0; p > q; q++) b.weekNumbers.push(h(b.rows[q][o].date)) } }, e.compare = function (a, b) { return new Date(a.getFullYear(), a.getMonth(), a.getDate()) - new Date(b.getFullYear(), b.getMonth(), b.getDate()) }, e.handleKeyDown = function (a) { var b = e.activeDate.getDate(); if ("left" === a) b -= 1; else if ("up" === a) b -= 7; else if ("right" === a) b += 1; else if ("down" === a) b += 7; else if ("pageup" === a || "pagedown" === a) { var c = e.activeDate.getMonth() + ("pageup" === a ? -1 : 1); e.activeDate.setMonth(c, 1), b = Math.min(f(e.activeDate.getFullYear(), e.activeDate.getMonth()), b) } else "home" === a ? b = 1 : "end" === a && (b = f(e.activeDate.getFullYear(), e.activeDate.getMonth())); e.activeDate.setDate(b) }, e.refreshView() } } }]).directive("monthpicker", ["dateFilter", function (a) { return { restrict: "EA", replace: !0, templateUrl: "template/datepicker/month.html", require: "^datepicker", link: function (b, c, d, e) { e.step = { years: 1 }, e.element = c, e._refreshView = function () { for (var c = new Array(12), d = e.activeDate.getFullYear(), f = 0; 12 > f; f++) c[f] = angular.extend(e.createDateObject(new Date(d, f, 1), e.formatMonth), { uid: b.uniqueId + "-" + f }); b.title = a(e.activeDate, e.formatMonthTitle), b.rows = e.split(c, 3) }, e.compare = function (a, b) { return new Date(a.getFullYear(), a.getMonth()) - new Date(b.getFullYear(), b.getMonth()) }, e.handleKeyDown = function (a) { var b = e.activeDate.getMonth(); if ("left" === a) b -= 1; else if ("up" === a) b -= 3; else if ("right" === a) b += 1; else if ("down" === a) b += 3; else if ("pageup" === a || "pagedown" === a) { var c = e.activeDate.getFullYear() + ("pageup" === a ? -1 : 1); e.activeDate.setFullYear(c) } else "home" === a ? b = 0 : "end" === a && (b = 11); e.activeDate.setMonth(b) }, e.refreshView() } } }]).directive("yearpicker", ["dateFilter", function () { return { restrict: "EA", replace: !0, templateUrl: "template/datepicker/year.html", require: "^datepicker", link: function (a, b, c, d) { function e(a) { return parseInt((a - 1) / f, 10) * f + 1 } var f = d.yearRange; d.step = { years: f }, d.element = b, d._refreshView = function () { for (var b = new Array(f), c = 0, g = e(d.activeDate.getFullYear()) ; f > c; c++) b[c] = angular.extend(d.createDateObject(new Date(g + c, 0, 1), d.formatYear), { uid: a.uniqueId + "-" + c }); a.title = [b[0].label, b[f - 1].label].join(" - "), a.rows = d.split(b, 5) }, d.compare = function (a, b) { return a.getFullYear() - b.getFullYear() }, d.handleKeyDown = function (a) { var b = d.activeDate.getFullYear(); "left" === a ? b -= 1 : "up" === a ? b -= 5 : "right" === a ? b += 1 : "down" === a ? b += 5 : "pageup" === a || "pagedown" === a ? b += ("pageup" === a ? -1 : 1) * d.step.years : "home" === a ? b = e(d.activeDate.getFullYear()) : "end" === a && (b = e(d.activeDate.getFullYear()) + f - 1), d.activeDate.setFullYear(b) }, d.refreshView() } } }]).constant("datepickerPopupConfig", { datepickerPopup: "yyyy-MM-dd", html5Types: { date: "yyyy-MM-dd", "datetime-local": "yyyy-MM-ddTHH:mm:ss.sss", month: "yyyy-MM" }, currentText: "Today", clearText: "Clear", closeText: "Done", closeOnDateSelection: !0, appendToBody: !1, showButtonBar: !0 }).directive("datepickerPopup", ["$compile", "$parse", "$document", "$position", "dateFilter", "dateParser", "datepickerPopupConfig", function (a, b, c, d, e, f, g) { return { restrict: "EA", require: "ngModel", scope: { isOpen: "=?", currentText: "@", clearText: "@", closeText: "@", dateDisabled: "&", customClass: "&" }, link: function (h, i, j, k) { function l(a) { return a.replace(/([A-Z])/g, function (a) { return "-" + a.toLowerCase() }) } function m(a) { if (angular.isNumber(a) && (a = new Date(a)), a) { if (angular.isDate(a) && !isNaN(a)) return a; if (angular.isString(a)) { var b = f.parse(a, o, h.date) || new Date(a); return isNaN(b) ? void 0 : b } return void 0 } return null } function n(a, b) { var c = a || b; if (angular.isNumber(c) && (c = new Date(c)), c) { if (angular.isDate(c) && !isNaN(c)) return !0; if (angular.isString(c)) { var d = f.parse(c, o) || new Date(c); return !isNaN(d) } return !1 } return !0 } var o, p = angular.isDefined(j.closeOnDateSelection) ? h.$parent.$eval(j.closeOnDateSelection) : g.closeOnDateSelection, q = angular.isDefined(j.datepickerAppendToBody) ? h.$parent.$eval(j.datepickerAppendToBody) : g.appendToBody; h.showButtonBar = angular.isDefined(j.showButtonBar) ? h.$parent.$eval(j.showButtonBar) : g.showButtonBar, h.getText = function (a) { return h[a + "Text"] || g[a + "Text"] }; var r = !1; if (g.html5Types[j.type] ? (o = g.html5Types[j.type], r = !0) : (o = j.datepickerPopup || g.datepickerPopup, j.$observe("datepickerPopup", function (a) { var b = a || g.datepickerPopup; if (b !== o && (o = b, k.$modelValue = null, !o)) throw new Error("datepickerPopup must have a date format specified.") })), !o) throw new Error("datepickerPopup must have a date format specified."); if (r && j.datepickerPopup) throw new Error("HTML5 date input types do not support custom formats."); var s = angular.element("<div datepicker-popup-wrap><div datepicker></div></div>"); s.attr({ "ng-model": "date", "ng-change": "dateSelection()" }); var t = angular.element(s.children()[0]); if (r && "month" == j.type && (t.attr("datepicker-mode", '"month"'), t.attr("min-mode", "month")), j.datepickerOptions) { var u = h.$parent.$eval(j.datepickerOptions); u.initDate && (h.initDate = u.initDate, t.attr("init-date", "initDate"), delete u.initDate), angular.forEach(u, function (a, b) { t.attr(l(b), a) }) } h.watchData = {}, angular.forEach(["minDate", "maxDate", "datepickerMode", "initDate", "shortcutPropagation"], function (a) { if (j[a]) { var c = b(j[a]); if (h.$parent.$watch(c, function (b) { h.watchData[a] = b }), t.attr(l(a), "watchData." + a), "datepickerMode" === a) { var d = c.assign; h.$watch("watchData." + a, function (a, b) { a !== b && d(h.$parent, a) }) } } }), j.dateDisabled && t.attr("date-disabled", "dateDisabled({ date: date, mode: mode })"), j.showWeeks && t.attr("show-weeks", j.showWeeks), j.customClass && t.attr("custom-class", "customClass({ date: date, mode: mode })"), r ? k.$formatters.push(function (a) { return h.date = a, a }) : (k.$$parserName = "date", k.$validators.date = n, k.$parsers.unshift(m), k.$formatters.push(function (a) { return h.date = a, k.$isEmpty(a) ? a : e(a, o) })), h.dateSelection = function (a) { angular.isDefined(a) && (h.date = a); var b = h.date ? e(h.date, o) : ""; i.val(b), k.$setViewValue(b), p && (h.isOpen = !1, i[0].focus()) }, k.$viewChangeListeners.push(function () { h.date = f.parse(k.$viewValue, o, h.date) || new Date(k.$viewValue) }); var v = function (a) { h.isOpen && a.target !== i[0] && h.$apply(function () { h.isOpen = !1 }) }, w = function (a) { h.keydown(a) }; i.bind("keydown", w), h.keydown = function (a) { 27 === a.which ? (a.preventDefault(), h.isOpen && a.stopPropagation(), h.close()) : 40 !== a.which || h.isOpen || (h.isOpen = !0) }, h.$watch("isOpen", function (a) { a ? (h.$broadcast("datepicker.focus"), h.position = q ? d.offset(i) : d.position(i), h.position.top = h.position.top + i.prop("offsetHeight"), c.bind("click", v)) : c.unbind("click", v) }), h.select = function (a) { if ("today" === a) { var b = new Date; angular.isDate(h.date) ? (a = new Date(h.date), a.setFullYear(b.getFullYear(), b.getMonth(), b.getDate())) : a = new Date(b.setHours(0, 0, 0, 0)) } h.dateSelection(a) }, h.close = function () { h.isOpen = !1, i[0].focus() }; var x = a(s)(h); s.remove(), q ? c.find("body").append(x) : i.after(x), h.$on("$destroy", function () { x.remove(), i.unbind("keydown", w), c.unbind("click", v) }) } } }]).directive("datepickerPopupWrap", function () { return { restrict: "EA", replace: !0, transclude: !0, templateUrl: "template/datepicker/popup.html", link: function (a, b) { b.bind("click", function (a) { a.preventDefault(), a.stopPropagation() }) } } }), angular.module("ui.bootstrap.dropdown", ["ui.bootstrap.position"]).constant("dropdownConfig", { openClass: "open" }).service("dropdownService", ["$document", "$rootScope", function (a, b) { var c = null; this.open = function (b) { c || (a.bind("click", d), a.bind("keydown", e)), c && c !== b && (c.isOpen = !1), c = b }, this.close = function (b) { c === b && (c = null, a.unbind("click", d), a.unbind("keydown", e)) }; var d = function (a) { if (c && (!a || "disabled" !== c.getAutoClose())) { var d = c.getToggleElement(); if (!(a && d && d[0].contains(a.target))) { var e = c.getElement(); a && "outsideClick" === c.getAutoClose() && e && e[0].contains(a.target) || (c.isOpen = !1, b.$$phase || c.$apply()) } } }, e = function (a) { 27 === a.which && (c.focusToggleElement(), d()) } }]).controller("DropdownController", ["$scope", "$attrs", "$parse", "dropdownConfig", "dropdownService", "$animate", "$position", "$document", function (a, b, c, d, e, f, g, h) { var i, j = this, k = a.$new(), l = d.openClass, m = angular.noop, n = b.onToggle ? c(b.onToggle) : angular.noop, o = !1; this.init = function (d) { j.$element = d, b.isOpen && (i = c(b.isOpen), m = i.assign, a.$watch(i, function (a) { k.isOpen = !!a })), o = angular.isDefined(b.dropdownAppendToBody), o && j.dropdownMenu && (h.find("body").append(j.dropdownMenu), d.on("$destroy", function () { j.dropdownMenu.remove() })) }, this.toggle = function (a) { return k.isOpen = arguments.length ? !!a : !k.isOpen }, this.isOpen = function () { return k.isOpen }, k.getToggleElement = function () { return j.toggleElement }, k.getAutoClose = function () { return b.autoClose || "always" }, k.getElement = function () { return j.$element }, k.focusToggleElement = function () { j.toggleElement && j.toggleElement[0].focus() }, k.$watch("isOpen", function (b, c) { if (o && j.dropdownMenu) { var d = g.positionElements(j.$element, j.dropdownMenu, "bottom-left", !0); j.dropdownMenu.css({ top: d.top + "px", left: d.left + "px", display: b ? "block" : "none" }) } f[b ? "addClass" : "removeClass"](j.$element, l), b ? (k.focusToggleElement(), e.open(k)) : e.close(k), m(a, b), angular.isDefined(b) && b !== c && n(a, { open: !!b }) }), a.$on("$locationChangeSuccess", function () { k.isOpen = !1 }), a.$on("$destroy", function () { k.$destroy() }) }]).directive("dropdown", function () { return { controller: "DropdownController", link: function (a, b, c, d) { d.init(b) } } }).directive("dropdownMenu", function () { return { restrict: "AC", require: "?^dropdown", link: function (a, b, c, d) { d && (d.dropdownMenu = b) } } }).directive("dropdownToggle", function () { return { require: "?^dropdown", link: function (a, b, c, d) { if (d) { d.toggleElement = b; var e = function (e) { e.preventDefault(), b.hasClass("disabled") || c.disabled || a.$apply(function () { d.toggle() }) }; b.bind("click", e), b.attr({ "aria-haspopup": !0, "aria-expanded": !1 }), a.$watch(d.isOpen, function (a) { b.attr("aria-expanded", !!a) }), a.$on("$destroy", function () { b.unbind("click", e) }) } } } }), angular.module("ui.bootstrap.modal", []).factory("$$stackedMap", function () { return { createNew: function () { var a = []; return { add: function (b, c) { a.push({ key: b, value: c }) }, get: function (b) { for (var c = 0; c < a.length; c++) if (b == a[c].key) return a[c] }, keys: function () { for (var b = [], c = 0; c < a.length; c++) b.push(a[c].key); return b }, top: function () { return a[a.length - 1] }, remove: function (b) { for (var c = -1, d = 0; d < a.length; d++) if (b == a[d].key) { c = d; break } return a.splice(c, 1)[0] }, removeTop: function () { return a.splice(a.length - 1, 1)[0] }, length: function () { return a.length } } } } }).directive("modalBackdrop", ["$timeout", function (a) { function b(b) { b.animate = !1, a(function () { b.animate = !0 }) } return { restrict: "EA", replace: !0, templateUrl: "template/modal/backdrop.html", compile: function (a, c) { return a.addClass(c.backdropClass), b } } }]).directive("modalWindow", ["$modalStack", "$q", function (a, b) { return { restrict: "EA", scope: { index: "@", animate: "=" }, replace: !0, transclude: !0, templateUrl: function (a, b) { return b.templateUrl || "template/modal/window.html" }, link: function (c, d, e) { d.addClass(e.windowClass || ""), c.size = e.size, c.close = function (b) { var c = a.getTop(); c && c.value.backdrop && "static" != c.value.backdrop && b.target === b.currentTarget && (b.preventDefault(), b.stopPropagation(), a.dismiss(c.key, "backdrop click")) }, c.$isRendered = !0; var f = b.defer(); e.$observe("modalRender", function (a) { "true" == a && f.resolve() }), f.promise.then(function () { c.animate = !0; var b = d[0].querySelectorAll("[autofocus]"); b.length ? b[0].focus() : d[0].focus(); var e = a.getTop(); e && a.modalRendered(e.key) }) } } }]).directive("modalAnimationClass", [function () { return { compile: function (a, b) { b.modalAnimation && a.addClass(b.modalAnimationClass) } } }]).directive("modalTransclude", function () { return { link: function (a, b, c, d, e) { e(a.$parent, function (a) { b.empty(), b.append(a) }) } } }).factory("$modalStack", ["$animate", "$timeout", "$document", "$compile", "$rootScope", "$$stackedMap", function (a, b, c, d, e, f) { function g() { for (var a = -1, b = o.keys(), c = 0; c < b.length; c++) o.get(b[c]).value.backdrop && (a = c); return a } function h(a) { var b = c.find("body").eq(0), d = o.get(a).value; o.remove(a), j(d.modalDomEl, d.modalScope, function () { b.toggleClass(n, o.length() > 0), i() }) } function i() { if (l && -1 == g()) { var a = m; j(l, m, function () { a = null }), l = void 0, m = void 0 } } function j(c, d, f) { function g() { g.done || (g.done = !0, c.remove(), d.$destroy(), f && f()) } d.animate = !1, c.attr("modal-animation") && a.enabled() ? c.one("$animate:close", function () { e.$evalAsync(g) }) : b(g) } function k(a, b, c) { return !a.value.modalScope.$broadcast("modal.closing", b, c).defaultPrevented } var l, m, n = "modal-open", o = f.createNew(), p = {}; return e.$watch(g, function (a) { m && (m.index = a) }), c.bind("keydown", function (a) { var b; 27 === a.which && (b = o.top(), b && b.value.keyboard && (a.preventDefault(), e.$apply(function () { p.dismiss(b.key, "escape key press") }))) }), p.open = function (a, b) { var f = c[0].activeElement; o.add(a, { deferred: b.deferred, renderDeferred: b.renderDeferred, modalScope: b.scope, backdrop: b.backdrop, keyboard: b.keyboard }); var h = c.find("body").eq(0), i = g(); if (i >= 0 && !l) { m = e.$new(!0), m.index = i; var j = angular.element('<div modal-backdrop="modal-backdrop"></div>'); j.attr("backdrop-class", b.backdropClass), b.animation && j.attr("modal-animation", "true"), l = d(j)(m), h.append(l) } var k = angular.element('<div modal-window="modal-window"></div>'); k.attr({ "template-url": b.windowTemplateUrl, "window-class": b.windowClass, size: b.size, index: o.length() - 1, animate: "animate" }).html(b.content), b.animation && k.attr("modal-animation", "true"); var p = d(k)(b.scope); o.top().value.modalDomEl = p, o.top().value.modalOpener = f, h.append(p), h.addClass(n) }, p.close = function (a, b) { var c = o.get(a); return c && k(c, b, !0) ? (c.value.deferred.resolve(b), h(a), c.value.modalOpener.focus(), !0) : !c }, p.dismiss = function (a, b) { var c = o.get(a); return c && k(c, b, !1) ? (c.value.deferred.reject(b), h(a), c.value.modalOpener.focus(), !0) : !c }, p.dismissAll = function (a) { for (var b = this.getTop() ; b && this.dismiss(b.key, a) ;) b = this.getTop() }, p.getTop = function () { return o.top() }, p.modalRendered = function (a) { var b = o.get(a); b && b.value.renderDeferred.resolve() }, p }]).provider("$modal", function () {
//    var a = {
//        options: { animation: !0, backdrop: !0, keyboard: !0 }, $get: ["$injector", "$rootScope", "$q", "$templateRequest", "$controller", "$modalStack", function (b, c, d, e, f, g) {
//            function h(a) { return a.template ? d.when(a.template) : e(angular.isFunction(a.templateUrl) ? a.templateUrl() : a.templateUrl) } function i(a) {
//                var c = []; return angular.forEach(a, function (a) {
//                    (angular.isFunction(a) || angular.isArray(a)) && c.push(d.when(b.invoke(a)))
//                }), c
//            } var j = {}; return j.open = function (b) { var e = d.defer(), j = d.defer(), k = d.defer(), l = { result: e.promise, opened: j.promise, rendered: k.promise, close: function (a) { return g.close(l, a) }, dismiss: function (a) { return g.dismiss(l, a) } }; if (b = angular.extend({}, a.options, b), b.resolve = b.resolve || {}, !b.template && !b.templateUrl) throw new Error("One of template or templateUrl options is required."); var m = d.all([h(b)].concat(i(b.resolve))); return m.then(function (a) { var d = (b.scope || c).$new(); d.$close = l.close, d.$dismiss = l.dismiss; var h, i = {}, j = 1; b.controller && (i.$scope = d, i.$modalInstance = l, angular.forEach(b.resolve, function (b, c) { i[c] = a[j++] }), h = f(b.controller, i), b.controllerAs && (d[b.controllerAs] = h)), g.open(l, { scope: d, deferred: e, renderDeferred: k, content: a[0], animation: b.animation, backdrop: b.backdrop, keyboard: b.keyboard, backdropClass: b.backdropClass, windowClass: b.windowClass, windowTemplateUrl: b.windowTemplateUrl, size: b.size }) }, function (a) { e.reject(a) }), m.then(function () { j.resolve(!0) }, function (a) { j.reject(a) }), l }, j
//        }]
//    }; return a
//}), angular.module("ui.bootstrap.pagination", []).controller("PaginationController", ["$scope", "$attrs", "$parse", function (a, b, c) { var d = this, e = { $setViewValue: angular.noop }, f = b.numPages ? c(b.numPages).assign : angular.noop; this.init = function (g, h) { e = g, this.config = h, e.$render = function () { d.render() }, b.itemsPerPage ? a.$parent.$watch(c(b.itemsPerPage), function (b) { d.itemsPerPage = parseInt(b, 10), a.totalPages = d.calculateTotalPages() }) : this.itemsPerPage = h.itemsPerPage, a.$watch("totalItems", function () { a.totalPages = d.calculateTotalPages() }), a.$watch("totalPages", function (b) { f(a.$parent, b), a.page > b ? a.selectPage(b) : e.$render() }) }, this.calculateTotalPages = function () { var b = this.itemsPerPage < 1 ? 1 : Math.ceil(a.totalItems / this.itemsPerPage); return Math.max(b || 0, 1) }, this.render = function () { a.page = parseInt(e.$viewValue, 10) || 1 }, a.selectPage = function (b, c) { a.page !== b && b > 0 && b <= a.totalPages && (c && c.target && c.target.blur(), e.$setViewValue(b), e.$render()) }, a.getText = function (b) { return a[b + "Text"] || d.config[b + "Text"] }, a.noPrevious = function () { return 1 === a.page }, a.noNext = function () { return a.page === a.totalPages } }]).constant("paginationConfig", { itemsPerPage: 10, boundaryLinks: !1, directionLinks: !0, firstText: "First", previousText: "Previous", nextText: "Next", lastText: "Last", rotate: !0 }).directive("pagination", ["$parse", "paginationConfig", function (a, b) { return { restrict: "EA", scope: { totalItems: "=", firstText: "@", previousText: "@", nextText: "@", lastText: "@" }, require: ["pagination", "?ngModel"], controller: "PaginationController", templateUrl: "template/pagination/pagination.html", replace: !0, link: function (c, d, e, f) { function g(a, b, c) { return { number: a, text: b, active: c } } function h(a, b) { var c = [], d = 1, e = b, f = angular.isDefined(k) && b > k; f && (l ? (d = Math.max(a - Math.floor(k / 2), 1), e = d + k - 1, e > b && (e = b, d = e - k + 1)) : (d = (Math.ceil(a / k) - 1) * k + 1, e = Math.min(d + k - 1, b))); for (var h = d; e >= h; h++) { var i = g(h, h, h === a); c.push(i) } if (f && !l) { if (d > 1) { var j = g(d - 1, "...", !1); c.unshift(j) } if (b > e) { var m = g(e + 1, "...", !1); c.push(m) } } return c } var i = f[0], j = f[1]; if (j) { var k = angular.isDefined(e.maxSize) ? c.$parent.$eval(e.maxSize) : b.maxSize, l = angular.isDefined(e.rotate) ? c.$parent.$eval(e.rotate) : b.rotate; c.boundaryLinks = angular.isDefined(e.boundaryLinks) ? c.$parent.$eval(e.boundaryLinks) : b.boundaryLinks, c.directionLinks = angular.isDefined(e.directionLinks) ? c.$parent.$eval(e.directionLinks) : b.directionLinks, i.init(j, b), e.maxSize && c.$parent.$watch(a(e.maxSize), function (a) { k = parseInt(a, 10), i.render() }); var m = i.render; i.render = function () { m(), c.page > 0 && c.page <= c.totalPages && (c.pages = h(c.page, c.totalPages)) } } } } }]).constant("pagerConfig", { itemsPerPage: 10, previousText: "« Previous", nextText: "Next »", align: !0 }).directive("pager", ["pagerConfig", function (a) { return { restrict: "EA", scope: { totalItems: "=", previousText: "@", nextText: "@" }, require: ["pager", "?ngModel"], controller: "PaginationController", templateUrl: "template/pagination/pager.html", replace: !0, link: function (b, c, d, e) { var f = e[0], g = e[1]; g && (b.align = angular.isDefined(d.align) ? b.$parent.$eval(d.align) : a.align, f.init(g, a)) } } }]), angular.module("ui.bootstrap.tooltip", ["ui.bootstrap.position", "ui.bootstrap.bindHtml"]).provider("$tooltip", function () { function a(a) { var b = /[A-Z]/g, c = "-"; return a.replace(b, function (a, b) { return (b ? c : "") + a.toLowerCase() }) } var b = { placement: "top", animation: !0, popupDelay: 0, useContentExp: !1 }, c = { mouseenter: "mouseleave", click: "click", focus: "blur" }, d = {}; this.options = function (a) { angular.extend(d, a) }, this.setTriggers = function (a) { angular.extend(c, a) }, this.$get = ["$window", "$compile", "$timeout", "$document", "$position", "$interpolate", function (e, f, g, h, i, j) { return function (e, k, l, m) { function n(a) { var b = a || m.trigger || l, d = c[b] || b; return { show: b, hide: d } } m = angular.extend({}, b, d, m); var o = a(e), p = j.startSymbol(), q = j.endSymbol(), r = "<div " + o + '-popup title="' + p + "title" + q + '" ' + (m.useContentExp ? 'content-exp="contentExp()" ' : 'content="' + p + "content" + q + '" ') + 'placement="' + p + "placement" + q + '" popup-class="' + p + "popupClass" + q + '" animation="animation" is-open="isOpen"origin-scope="origScope" ></div>'; return { restrict: "EA", compile: function () { var a = f(r); return function (b, c, d) { function f() { E.isOpen ? l() : j() } function j() { (!D || b.$eval(d[k + "Enable"])) && (s(), E.popupDelay ? A || (A = g(o, E.popupDelay, !1), A.then(function (a) { a() })) : o()()) } function l() { b.$apply(function () { p() }) } function o() { return A = null, z && (g.cancel(z), z = null), (m.useContentExp ? E.contentExp() : E.content) ? (q(), x.css({ top: 0, left: 0, display: "block" }), E.$digest(), F(), E.isOpen = !0, E.$apply(), F) : angular.noop } function p() { E.isOpen = !1, g.cancel(A), A = null, E.animation ? z || (z = g(r, 500)) : r() } function q() { x && r(), y = E.$new(), x = a(y, function (a) { B ? h.find("body").append(a) : c.after(a) }), y.$watch(function () { g(F, 0, !1) }), m.useContentExp && y.$watch("contentExp()", function (a) { !a && E.isOpen && p() }) } function r() { z = null, x && (x.remove(), x = null), y && (y.$destroy(), y = null) } function s() { t(), u(), v() } function t() { E.popupClass = d[k + "Class"] } function u() { var a = d[k + "Placement"]; E.placement = angular.isDefined(a) ? a : m.placement } function v() { var a = d[k + "PopupDelay"], b = parseInt(a, 10); E.popupDelay = isNaN(b) ? m.popupDelay : b } function w() { var a = d[k + "Trigger"]; G(), C = n(a), C.show === C.hide ? c.bind(C.show, f) : (c.bind(C.show, j), c.bind(C.hide, l)) } var x, y, z, A, B = angular.isDefined(m.appendToBody) ? m.appendToBody : !1, C = n(void 0), D = angular.isDefined(d[k + "Enable"]), E = b.$new(!0), F = function () { if (x) { var a = i.positionElements(c, x, E.placement, B); a.top += "px", a.left += "px", x.css(a) } }; E.origScope = b, E.isOpen = !1, E.contentExp = function () { return b.$eval(d[e]) }, m.useContentExp || d.$observe(e, function (a) { E.content = a, !a && E.isOpen && p() }), d.$observe("disabled", function (a) { a && E.isOpen && p() }), d.$observe(k + "Title", function (a) { E.title = a }); var G = function () { c.unbind(C.show, j), c.unbind(C.hide, l) }; w(); var H = b.$eval(d[k + "Animation"]); E.animation = angular.isDefined(H) ? !!H : m.animation; var I = b.$eval(d[k + "AppendToBody"]); B = angular.isDefined(I) ? I : B, B && b.$on("$locationChangeSuccess", function () { E.isOpen && p() }), b.$on("$destroy", function () { g.cancel(z), g.cancel(A), G(), r(), E = null }) } } } } }] }).directive("tooltipTemplateTransclude", ["$animate", "$sce", "$compile", "$templateRequest", function (a, b, c, d) { return { link: function (e, f, g) { var h, i, j, k = e.$eval(g.tooltipTemplateTranscludeScope), l = 0, m = function () { i && (i.remove(), i = null), h && (h.$destroy(), h = null), j && (a.leave(j).then(function () { i = null }), i = j, j = null) }; e.$watch(b.parseAsResourceUrl(g.tooltipTemplateTransclude), function (b) { var g = ++l; b ? (d(b, !0).then(function (d) { if (g === l) { var e = k.$new(), i = d, n = c(i)(e, function (b) { m(), a.enter(b, f) }); h = e, j = n, h.$emit("$includeContentLoaded", b) } }, function () { g === l && (m(), e.$emit("$includeContentError", b)) }), e.$emit("$includeContentRequested", b)) : m() }), e.$on("$destroy", m) } } }]).directive("tooltipClasses", function () { return { restrict: "A", link: function (a, b, c) { a.placement && b.addClass(a.placement), a.popupClass && b.addClass(a.popupClass), a.animation() && b.addClass(c.tooltipAnimationClass) } } }).directive("tooltipPopup", function () { return { restrict: "EA", replace: !0, scope: { content: "@", placement: "@", popupClass: "@", animation: "&", isOpen: "&" }, templateUrl: "template/tooltip/tooltip-popup.html" } }).directive("tooltip", ["$tooltip", function (a) { return a("tooltip", "tooltip", "mouseenter") }]).directive("tooltipTemplatePopup", function () { return { restrict: "EA", replace: !0, scope: { contentExp: "&", placement: "@", popupClass: "@", animation: "&", isOpen: "&", originScope: "&" }, templateUrl: "template/tooltip/tooltip-template-popup.html" } }).directive("tooltipTemplate", ["$tooltip", function (a) { return a("tooltipTemplate", "tooltip", "mouseenter", { useContentExp: !0 }) }]).directive("tooltipHtmlPopup", function () { return { restrict: "EA", replace: !0, scope: { contentExp: "&", placement: "@", popupClass: "@", animation: "&", isOpen: "&" }, templateUrl: "template/tooltip/tooltip-html-popup.html" } }).directive("tooltipHtml", ["$tooltip", function (a) { return a("tooltipHtml", "tooltip", "mouseenter", { useContentExp: !0 }) }]).directive("tooltipHtmlUnsafePopup", function () { return { restrict: "EA", replace: !0, scope: { content: "@", placement: "@", popupClass: "@", animation: "&", isOpen: "&" }, templateUrl: "template/tooltip/tooltip-html-unsafe-popup.html" } }).value("tooltipHtmlUnsafeSuppressDeprecated", !1).directive("tooltipHtmlUnsafe", ["$tooltip", "tooltipHtmlUnsafeSuppressDeprecated", "$log", function (a, b, c) { return b || c.warn("tooltip-html-unsafe is now deprecated. Use tooltip-html or tooltip-template instead."), a("tooltipHtmlUnsafe", "tooltip", "mouseenter") }]), angular.module("ui.bootstrap.popover", ["ui.bootstrap.tooltip"]).directive("popoverTemplatePopup", function () { return { restrict: "EA", replace: !0, scope: { title: "@", contentExp: "&", placement: "@", popupClass: "@", animation: "&", isOpen: "&", originScope: "&" }, templateUrl: "template/popover/popover-template.html" } }).directive("popoverTemplate", ["$tooltip", function (a) { return a("popoverTemplate", "popover", "click", { useContentExp: !0 }) }]).directive("popoverPopup", function () { return { restrict: "EA", replace: !0, scope: { title: "@", content: "@", placement: "@", popupClass: "@", animation: "&", isOpen: "&" }, templateUrl: "template/popover/popover.html" } }).directive("popover", ["$tooltip", function (a) { return a("popover", "popover", "click") }]), angular.module("ui.bootstrap.progressbar", []).constant("progressConfig", { animate: !0, max: 100 }).controller("ProgressController", ["$scope", "$attrs", "progressConfig", function (a, b, c) { var d = this, e = angular.isDefined(b.animate) ? a.$parent.$eval(b.animate) : c.animate; this.bars = [], a.max = angular.isDefined(a.max) ? a.max : c.max, this.addBar = function (b, c) { e || c.css({ transition: "none" }), this.bars.push(b), b.$watch("value", function (c) { b.percent = +(100 * c / a.max).toFixed(2) }), b.$on("$destroy", function () { c = null, d.removeBar(b) }) }, this.removeBar = function (a) { this.bars.splice(this.bars.indexOf(a), 1) } }]).directive("progress", function () { return { restrict: "EA", replace: !0, transclude: !0, controller: "ProgressController", require: "progress", scope: {}, templateUrl: "template/progressbar/progress.html" } }).directive("bar", function () { return { restrict: "EA", replace: !0, transclude: !0, require: "^progress", scope: { value: "=", max: "=?", type: "@" }, templateUrl: "template/progressbar/bar.html", link: function (a, b, c, d) { d.addBar(a, b) } } }).directive("progressbar", function () { return { restrict: "EA", replace: !0, transclude: !0, controller: "ProgressController", scope: { value: "=", max: "=?", type: "@" }, templateUrl: "template/progressbar/progressbar.html", link: function (a, b, c, d) { d.addBar(a, angular.element(b.children()[0])) } } }), angular.module("ui.bootstrap.rating", []).constant("ratingConfig", { max: 5, stateOn: null, stateOff: null }).controller("RatingController", ["$scope", "$attrs", "ratingConfig", function (a, b, c) { var d = { $setViewValue: angular.noop }; this.init = function (e) { d = e, d.$render = this.render, d.$formatters.push(function (a) { return angular.isNumber(a) && a << 0 !== a && (a = Math.round(a)), a }), this.stateOn = angular.isDefined(b.stateOn) ? a.$parent.$eval(b.stateOn) : c.stateOn, this.stateOff = angular.isDefined(b.stateOff) ? a.$parent.$eval(b.stateOff) : c.stateOff; var f = angular.isDefined(b.ratingStates) ? a.$parent.$eval(b.ratingStates) : new Array(angular.isDefined(b.max) ? a.$parent.$eval(b.max) : c.max); a.range = this.buildTemplateObjects(f) }, this.buildTemplateObjects = function (a) { for (var b = 0, c = a.length; c > b; b++) a[b] = angular.extend({ index: b }, { stateOn: this.stateOn, stateOff: this.stateOff }, a[b]); return a }, a.rate = function (b) { !a.readonly && b >= 0 && b <= a.range.length && (d.$setViewValue(b), d.$render()) }, a.enter = function (b) { a.readonly || (a.value = b), a.onHover({ value: b }) }, a.reset = function () { a.value = d.$viewValue, a.onLeave() }, a.onKeydown = function (b) { /(37|38|39|40)/.test(b.which) && (b.preventDefault(), b.stopPropagation(), a.rate(a.value + (38 === b.which || 39 === b.which ? 1 : -1))) }, this.render = function () { a.value = d.$viewValue } }]).directive("rating", function () { return { restrict: "EA", require: ["rating", "ngModel"], scope: { readonly: "=?", onHover: "&", onLeave: "&" }, controller: "RatingController", templateUrl: "template/rating/rating.html", replace: !0, link: function (a, b, c, d) { var e = d[0], f = d[1]; e.init(f) } } }), angular.module("ui.bootstrap.tabs", []).controller("TabsetController", ["$scope", function (a) { var b = this, c = b.tabs = a.tabs = []; b.select = function (a) { angular.forEach(c, function (b) { b.active && b !== a && (b.active = !1, b.onDeselect()) }), a.active = !0, a.onSelect() }, b.addTab = function (a) { c.push(a), 1 === c.length && a.active !== !1 ? a.active = !0 : a.active ? b.select(a) : a.active = !1 }, b.removeTab = function (a) { var e = c.indexOf(a); if (a.active && c.length > 1 && !d) { var f = e == c.length - 1 ? e - 1 : e + 1; b.select(c[f]) } c.splice(e, 1) }; var d; a.$on("$destroy", function () { d = !0 }) }]).directive("tabset", function () { return { restrict: "EA", transclude: !0, replace: !0, scope: { type: "@" }, controller: "TabsetController", templateUrl: "template/tabs/tabset.html", link: function (a, b, c) { a.vertical = angular.isDefined(c.vertical) ? a.$parent.$eval(c.vertical) : !1, a.justified = angular.isDefined(c.justified) ? a.$parent.$eval(c.justified) : !1 } } }).directive("tab", ["$parse", "$log", function (a, b) { return { require: "^tabset", restrict: "EA", replace: !0, templateUrl: "template/tabs/tab.html", transclude: !0, scope: { active: "=?", heading: "@", onSelect: "&select", onDeselect: "&deselect" }, controller: function () { }, compile: function (c, d, e) { return function (c, d, f, g) { c.$watch("active", function (a) { a && g.select(c) }), c.disabled = !1, f.disable && c.$parent.$watch(a(f.disable), function (a) { c.disabled = !!a }), f.disabled && (b.warn('Use of "disabled" attribute has been deprecated, please use "disable"'), c.$parent.$watch(a(f.disabled), function (a) { c.disabled = !!a })), c.select = function () { c.disabled || (c.active = !0) }, g.addTab(c), c.$on("$destroy", function () { g.removeTab(c) }), c.$transcludeFn = e } } } }]).directive("tabHeadingTransclude", [function () { return { restrict: "A", require: "^tab", link: function (a, b) { a.$watch("headingElement", function (a) { a && (b.html(""), b.append(a)) }) } } }]).directive("tabContentTransclude", function () { function a(a) { return a.tagName && (a.hasAttribute("tab-heading") || a.hasAttribute("data-tab-heading") || "tab-heading" === a.tagName.toLowerCase() || "data-tab-heading" === a.tagName.toLowerCase()) } return { restrict: "A", require: "^tabset", link: function (b, c, d) { var e = b.$eval(d.tabContentTransclude); e.$transcludeFn(e.$parent, function (b) { angular.forEach(b, function (b) { a(b) ? e.headingElement = b : c.append(b) }) }) } } }), angular.module("ui.bootstrap.timepicker", []).constant("timepickerConfig", { hourStep: 1, minuteStep: 1, showMeridian: !0, meridians: null, readonlyInput: !1, mousewheel: !0, arrowkeys: !0 }).controller("TimepickerController", ["$scope", "$attrs", "$parse", "$log", "$locale", "timepickerConfig", function (a, b, c, d, e, f) { function g() { var b = parseInt(a.hours, 10), c = a.showMeridian ? b > 0 && 13 > b : b >= 0 && 24 > b; return c ? (a.showMeridian && (12 === b && (b = 0), a.meridian === p[1] && (b += 12)), b) : void 0 } function h() { var b = parseInt(a.minutes, 10); return b >= 0 && 60 > b ? b : void 0 } function i(a) { return angular.isDefined(a) && a.toString().length < 2 ? "0" + a : a.toString() } function j(a) { k(), o.$setViewValue(new Date(n)), l(a) } function k() { o.$setValidity("time", !0), a.invalidHours = !1, a.invalidMinutes = !1 } function l(b) { var c = n.getHours(), d = n.getMinutes(); a.showMeridian && (c = 0 === c || 12 === c ? 12 : c % 12), a.hours = "h" === b ? c : i(c), "m" !== b && (a.minutes = i(d)), a.meridian = n.getHours() < 12 ? p[0] : p[1] } function m(a) { var b = new Date(n.getTime() + 6e4 * a); n.setHours(b.getHours(), b.getMinutes()), j() } var n = new Date, o = { $setViewValue: angular.noop }, p = angular.isDefined(b.meridians) ? a.$parent.$eval(b.meridians) : f.meridians || e.DATETIME_FORMATS.AMPMS; this.init = function (c, d) { o = c, o.$render = this.render, o.$formatters.unshift(function (a) { return a ? new Date(a) : null }); var e = d.eq(0), g = d.eq(1), h = angular.isDefined(b.mousewheel) ? a.$parent.$eval(b.mousewheel) : f.mousewheel; h && this.setupMousewheelEvents(e, g); var i = angular.isDefined(b.arrowkeys) ? a.$parent.$eval(b.arrowkeys) : f.arrowkeys; i && this.setupArrowkeyEvents(e, g), a.readonlyInput = angular.isDefined(b.readonlyInput) ? a.$parent.$eval(b.readonlyInput) : f.readonlyInput, this.setupInputEvents(e, g) }; var q = f.hourStep; b.hourStep && a.$parent.$watch(c(b.hourStep), function (a) { q = parseInt(a, 10) }); var r = f.minuteStep; b.minuteStep && a.$parent.$watch(c(b.minuteStep), function (a) { r = parseInt(a, 10) }), a.showMeridian = f.showMeridian, b.showMeridian && a.$parent.$watch(c(b.showMeridian), function (b) { if (a.showMeridian = !!b, o.$error.time) { var c = g(), d = h(); angular.isDefined(c) && angular.isDefined(d) && (n.setHours(c), j()) } else l() }), this.setupMousewheelEvents = function (b, c) { var d = function (a) { a.originalEvent && (a = a.originalEvent); var b = a.wheelDelta ? a.wheelDelta : -a.deltaY; return a.detail || b > 0 }; b.bind("mousewheel wheel", function (b) { a.$apply(d(b) ? a.incrementHours() : a.decrementHours()), b.preventDefault() }), c.bind("mousewheel wheel", function (b) { a.$apply(d(b) ? a.incrementMinutes() : a.decrementMinutes()), b.preventDefault() }) }, this.setupArrowkeyEvents = function (b, c) { b.bind("keydown", function (b) { 38 === b.which ? (b.preventDefault(), a.incrementHours(), a.$apply()) : 40 === b.which && (b.preventDefault(), a.decrementHours(), a.$apply()) }), c.bind("keydown", function (b) { 38 === b.which ? (b.preventDefault(), a.incrementMinutes(), a.$apply()) : 40 === b.which && (b.preventDefault(), a.decrementMinutes(), a.$apply()) }) }, this.setupInputEvents = function (b, c) { if (a.readonlyInput) return a.updateHours = angular.noop, void (a.updateMinutes = angular.noop); var d = function (b, c) { o.$setViewValue(null), o.$setValidity("time", !1), angular.isDefined(b) && (a.invalidHours = b), angular.isDefined(c) && (a.invalidMinutes = c) }; a.updateHours = function () { var a = g(); angular.isDefined(a) ? (n.setHours(a), j("h")) : d(!0) }, b.bind("blur", function () { !a.invalidHours && a.hours < 10 && a.$apply(function () { a.hours = i(a.hours) }) }), a.updateMinutes = function () { var a = h(); angular.isDefined(a) ? (n.setMinutes(a), j("m")) : d(void 0, !0) }, c.bind("blur", function () { !a.invalidMinutes && a.minutes < 10 && a.$apply(function () { a.minutes = i(a.minutes) }) }) }, this.render = function () { var a = o.$viewValue; isNaN(a) ? (o.$setValidity("time", !1), d.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')) : (a && (n = a), k(), l()) }, a.incrementHours = function () { m(60 * q) }, a.decrementHours = function () { m(60 * -q) }, a.incrementMinutes = function () { m(r) }, a.decrementMinutes = function () { m(-r) }, a.toggleMeridian = function () { m(720 * (n.getHours() < 12 ? 1 : -1)) } }]).directive("timepicker", function () { return { restrict: "EA", require: ["timepicker", "?^ngModel"], controller: "TimepickerController", replace: !0, scope: {}, templateUrl: "template/timepicker/timepicker.html", link: function (a, b, c, d) { var e = d[0], f = d[1]; f && e.init(f, b.find("input")) } } }), angular.module("ui.bootstrap.transition", []).value("$transitionSuppressDeprecated", !1).factory("$transition", ["$q", "$timeout", "$rootScope", "$log", "$transitionSuppressDeprecated", function (a, b, c, d, e) { function f(a) { for (var b in a) if (void 0 !== h.style[b]) return a[b] } e || d.warn("$transition is now deprecated. Use $animate from ngAnimate instead."); var g = function (d, e, f) { f = f || {}; var h = a.defer(), i = g[f.animation ? "animationEndEventName" : "transitionEndEventName"], j = function () { c.$apply(function () { d.unbind(i, j), h.resolve(d) }) }; return i && d.bind(i, j), b(function () { angular.isString(e) ? d.addClass(e) : angular.isFunction(e) ? e(d) : angular.isObject(e) && d.css(e), i || h.resolve(d) }), h.promise.cancel = function () { i && d.unbind(i, j), h.reject("Transition cancelled") }, h.promise }, h = document.createElement("trans"), i = { WebkitTransition: "webkitTransitionEnd", MozTransition: "transitionend", OTransition: "oTransitionEnd", transition: "transitionend" }, j = { WebkitTransition: "webkitAnimationEnd", MozTransition: "animationend", OTransition: "oAnimationEnd", transition: "animationend" }; return g.transitionEndEventName = f(i), g.animationEndEventName = f(j), g }]), angular.module("ui.bootstrap.typeahead", ["ui.bootstrap.position", "ui.bootstrap.bindHtml"]).factory("typeaheadParser", ["$parse", function (a) { var b = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/; return { parse: function (c) { var d = c.match(b); if (!d) throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_" but got "' + c + '".'); return { itemName: d[3], source: a(d[4]), viewMapper: a(d[2] || d[1]), modelMapper: a(d[1]) } } } }]).directive("typeahead", ["$compile", "$parse", "$q", "$timeout", "$document", "$position", "typeaheadParser", function (a, b, c, d, e, f, g) { var h = [9, 13, 27, 38, 40]; return { require: "ngModel", link: function (i, j, k, l) { var m, n = i.$eval(k.typeaheadMinLength) || 1, o = i.$eval(k.typeaheadWaitMs) || 0, p = i.$eval(k.typeaheadEditable) !== !1, q = b(k.typeaheadLoading).assign || angular.noop, r = b(k.typeaheadOnSelect), s = k.typeaheadInputFormatter ? b(k.typeaheadInputFormatter) : void 0, t = k.typeaheadAppendToBody ? i.$eval(k.typeaheadAppendToBody) : !1, u = i.$eval(k.typeaheadFocusFirst) !== !1, v = b(k.ngModel).assign, w = g.parse(k.typeahead), x = i.$new(); i.$on("$destroy", function () { x.$destroy() }); var y = "typeahead-" + x.$id + "-" + Math.floor(1e4 * Math.random()); j.attr({ "aria-autocomplete": "list", "aria-expanded": !1, "aria-owns": y }); var z = angular.element("<div typeahead-popup></div>"); z.attr({ id: y, matches: "matches", active: "activeIdx", select: "select(activeIdx)", query: "query", position: "position" }), angular.isDefined(k.typeaheadTemplateUrl) && z.attr("template-url", k.typeaheadTemplateUrl); var A = function () { x.matches = [], x.activeIdx = -1, j.attr("aria-expanded", !1) }, B = function (a) { return y + "-option-" + a }; x.$watch("activeIdx", function (a) { 0 > a ? j.removeAttr("aria-activedescendant") : j.attr("aria-activedescendant", B(a)) }); var C = function (a) { var b = { $viewValue: a }; q(i, !0), c.when(w.source(i, b)).then(function (c) { var d = a === l.$viewValue; if (d && m) if (c && c.length > 0) { x.activeIdx = u ? 0 : -1, x.matches.length = 0; for (var e = 0; e < c.length; e++) b[w.itemName] = c[e], x.matches.push({ id: B(e), label: w.viewMapper(x, b), model: c[e] }); x.query = a, x.position = t ? f.offset(j) : f.position(j), x.position.top = x.position.top + j.prop("offsetHeight"), j.attr("aria-expanded", !0) } else A(); d && q(i, !1) }, function () { A(), q(i, !1) }) }; A(), x.query = void 0; var D, E = function (a) { D = d(function () { C(a) }, o) }, F = function () { D && d.cancel(D) }; l.$parsers.unshift(function (a) { return m = !0, a && a.length >= n ? o > 0 ? (F(), E(a)) : C(a) : (q(i, !1), F(), A()), p ? a : a ? void l.$setValidity("editable", !1) : (l.$setValidity("editable", !0), a) }), l.$formatters.push(function (a) { var b, c, d = {}; return p || l.$setValidity("editable", !0), s ? (d.$model = a, s(i, d)) : (d[w.itemName] = a, b = w.viewMapper(i, d), d[w.itemName] = void 0, c = w.viewMapper(i, d), b !== c ? b : a) }), x.select = function (a) { var b, c, e = {}; e[w.itemName] = c = x.matches[a].model, b = w.modelMapper(i, e), v(i, b), l.$setValidity("editable", !0), l.$setValidity("parse", !0), r(i, { $item: c, $model: b, $label: w.viewMapper(i, e) }), A(), d(function () { j[0].focus() }, 0, !1) }, j.bind("keydown", function (a) { 0 !== x.matches.length && -1 !== h.indexOf(a.which) && (-1 != x.activeIdx || 13 !== a.which && 9 !== a.which) && (a.preventDefault(), 40 === a.which ? (x.activeIdx = (x.activeIdx + 1) % x.matches.length, x.$digest()) : 38 === a.which ? (x.activeIdx = (x.activeIdx > 0 ? x.activeIdx : x.matches.length) - 1, x.$digest()) : 13 === a.which || 9 === a.which ? x.$apply(function () { x.select(x.activeIdx) }) : 27 === a.which && (a.stopPropagation(), A(), x.$digest())) }), j.bind("blur", function () { m = !1 }); var G = function (a) { j[0] !== a.target && (A(), x.$digest()) }; e.bind("click", G), i.$on("$destroy", function () { e.unbind("click", G), t && H.remove(), z.remove() }); var H = a(z)(x); t ? e.find("body").append(H) : j.after(H) } } }]).directive("typeaheadPopup", function () { return { restrict: "EA", scope: { matches: "=", query: "=", active: "=", position: "=", select: "&" }, replace: !0, templateUrl: "template/typeahead/typeahead-popup.html", link: function (a, b, c) { a.templateUrl = c.templateUrl, a.isOpen = function () { return a.matches.length > 0 }, a.isActive = function (b) { return a.active == b }, a.selectActive = function (b) { a.active = b }, a.selectMatch = function (b) { a.select({ activeIdx: b }) } } } }).directive("typeaheadMatch", ["$templateRequest", "$compile", "$parse", function (a, b, c) { return { restrict: "EA", scope: { index: "=", match: "=", query: "=" }, link: function (d, e, f) { var g = c(f.templateUrl)(d.$parent) || "template/typeahead/typeahead-match.html"; a(g).then(function (a) { b(a.trim())(d, function (a) { e.replaceWith(a) }) }) } } }]).filter("typeaheadHighlight", function () { function a(a) { return a.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1") } return function (b, c) { return c ? ("" + b).replace(new RegExp(a(c), "gi"), "<strong>$&</strong>") : b } }), angular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function (a) { a.put("template/accordion/accordion-group.html", '<div class="panel">\n  <div class="panel-heading">\n    <h4 class="panel-title">\n      <a href="javascript:void(0)" tabindex="0" class="accordion-toggle" ng-click="toggleOpen()" accordion-transclude="heading"><span ng-class="{\'text-muted\': isDisabled}">{{heading}}</span></a>\n    </h4>\n  </div>\n  <div class="panel-collapse collapse" collapse="!isOpen">\n	  <div class="panel-body" ng-transclude></div>\n  </div>\n</div>\n') }]), angular.module("template/accordion/accordion.html", []).run(["$templateCache", function (a) { a.put("template/accordion/accordion.html", '<div class="panel-group" ng-transclude></div>') }]), angular.module("template/alert/alert.html", []).run(["$templateCache", function (a) { a.put("template/alert/alert.html", '<div class="alert" ng-class="[\'alert-\' + (type || \'warning\'), closeable ? \'alert-dismissable\' : null]" role="alert">\n    <button ng-show="closeable" type="button" class="close" ng-click="close()">\n        <span aria-hidden="true">&times;</span>\n        <span class="sr-only">Close</span>\n    </button>\n    <div ng-transclude></div>\n</div>\n') }]), angular.module("template/carousel/carousel.html", []).run(["$templateCache", function (a) { a.put("template/carousel/carousel.html", '<div ng-mouseenter="pause()" ng-mouseleave="play()" class="carousel" ng-swipe-right="prev()" ng-swipe-left="next()">\n    <ol class="carousel-indicators" ng-show="slides.length > 1">\n        <li ng-repeat="slide in slides | orderBy:\'index\' track by $index" ng-class="{active: isActive(slide)}" ng-click="select(slide)"></li>\n    </ol>\n    <div class="carousel-inner" ng-transclude></div>\n    <a class="left carousel-control" ng-click="prev()" ng-show="slides.length > 1"><span class="glyphicon glyphicon-chevron-left"></span></a>\n    <a class="right carousel-control" ng-click="next()" ng-show="slides.length > 1"><span class="glyphicon glyphicon-chevron-right"></span></a>\n</div>\n') }]), angular.module("template/carousel/slide.html", []).run(["$templateCache", function (a) { a.put("template/carousel/slide.html", '<div ng-class="{\n    \'active\': active\n  }" class="item text-center" ng-transclude></div>\n') }]), angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function (a) { a.put("template/datepicker/datepicker.html", '<div ng-switch="datepickerMode" role="application" ng-keydown="keydown($event)">\n  <daypicker ng-switch-when="day" tabindex="0"></daypicker>\n  <monthpicker ng-switch-when="month" tabindex="0"></monthpicker>\n  <yearpicker ng-switch-when="year" tabindex="0"></yearpicker>\n</div>') }]), angular.module("template/datepicker/day.html", []).run(["$templateCache", function (a) { a.put("template/datepicker/day.html", '<table role="grid" aria-labelledby="{{uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th colspan="{{5 + showWeeks}}"><button id="{{uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n    <tr>\n      <th ng-show="showWeeks" class="text-center"></th>\n      <th ng-repeat="label in labels track by $index" class="text-center"><small aria-label="{{label.full}}">{{label.abbr}}</small></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat="row in rows track by $index">\n      <td ng-show="showWeeks" class="text-center h6"><em>{{ weekNumbers[$index] }}</em></td>\n      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{dt.uid}}" aria-disabled="{{!!dt.disabled}}" ng-class="dt.customClass">\n        <button type="button" style="width:100%;" class="btn btn-default btn-sm" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="{\'text-muted\': dt.secondary, \'text-info\': dt.current}">{{dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n') }]), angular.module("template/datepicker/month.html", []).run(["$templateCache", function (a) { a.put("template/datepicker/month.html", '<table role="grid" aria-labelledby="{{uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th><button id="{{uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat="row in rows track by $index">\n      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{dt.uid}}" aria-disabled="{{!!dt.disabled}}">\n        <button type="button" style="width:100%;" class="btn btn-default" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="{\'text-info\': dt.current}">{{dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n') }]), angular.module("template/datepicker/popup.html", []).run(["$templateCache", function (a) { a.put("template/datepicker/popup.html", '<ul class="dropdown-menu" ng-style="{display: (isOpen && \'block\') || \'none\', top: position.top+\'px\', left: position.left+\'px\'}" ng-keydown="keydown($event)">\n	<li ng-transclude></li>\n	<li ng-if="showButtonBar" style="padding:10px 9px 2px">\n		<span class="btn-group pull-left">\n			<button type="button" class="btn btn-sm btn-info" ng-click="select(\'today\')">{{ getText(\'current\') }}</button>\n			<button type="button" class="btn btn-sm btn-danger" ng-click="select(null)">{{ getText(\'clear\') }}</button>\n		</span>\n		<button type="button" class="btn btn-sm btn-success pull-right" ng-click="close()">{{ getText(\'close\') }}</button>\n	</li>\n</ul>\n') }]), angular.module("template/datepicker/year.html", []).run(["$templateCache", function (a) {
//    a.put("template/datepicker/year.html", '<table role="grid" aria-labelledby="{{uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th colspan="3"><button id="{{uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat="row in rows track by $index">\n      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{dt.uid}}" aria-disabled="{{!!dt.disabled}}">\n        <button type="button" style="width:100%;" class="btn btn-default" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="{\'text-info\': dt.current}">{{dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n')
//}]), angular.module("template/modal/backdrop.html", []).run(["$templateCache", function (a) { a.put("template/modal/backdrop.html", '<div class="modal-backdrop"\n     modal-animation-class="fade"\n     ng-class="{in: animate}"\n     ng-style="{\'z-index\': 1040 + (index && 1 || 0) + index*10}"\n></div>\n') }]), angular.module("template/modal/window.html", []).run(["$templateCache", function (a) { a.put("template/modal/window.html", '<div modal-render="{{$isRendered}}" tabindex="-1" role="dialog" class="modal"\n    modal-animation-class="fade"\n	ng-class="{in: animate}" ng-style="{\'z-index\': 1050 + index*10, display: \'block\'}" ng-click="close($event)">\n    <div class="modal-dialog" ng-class="size ? \'modal-\' + size : \'\'"><div class="modal-content" modal-transclude></div></div>\n</div>\n') }]), angular.module("template/pagination/pager.html", []).run(["$templateCache", function (a) { a.put("template/pagination/pager.html", '<ul class="pager">\n  <li ng-class="{disabled: noPrevious(), previous: align}"><a href ng-click="selectPage(page - 1, $event)">{{getText(\'previous\')}}</a></li>\n  <li ng-class="{disabled: noNext(), next: align}"><a href ng-click="selectPage(page + 1, $event)">{{getText(\'next\')}}</a></li>\n</ul>') }]), angular.module("template/pagination/pagination.html", []).run(["$templateCache", function (a) { a.put("template/pagination/pagination.html", '<ul class="pagination">\n  <li ng-if="boundaryLinks" ng-class="{disabled: noPrevious()}"><a href ng-click="selectPage(1, $event)">{{getText(\'first\')}}</a></li>\n  <li ng-if="directionLinks" ng-class="{disabled: noPrevious()}"><a href ng-click="selectPage(page - 1, $event)">{{getText(\'previous\')}}</a></li>\n  <li ng-repeat="page in pages track by $index" ng-class="{active: page.active}"><a href ng-click="selectPage(page.number, $event)">{{page.text}}</a></li>\n  <li ng-if="directionLinks" ng-class="{disabled: noNext()}"><a href ng-click="selectPage(page + 1, $event)">{{getText(\'next\')}}</a></li>\n  <li ng-if="boundaryLinks" ng-class="{disabled: noNext()}"><a href ng-click="selectPage(totalPages, $event)">{{getText(\'last\')}}</a></li>\n</ul>') }]), angular.module("template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function (a) { a.put("template/tooltip/tooltip-html-popup.html", '<div class="tooltip"\n  tooltip-animation-class="fade"\n  tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" ng-bind-html="contentExp()"></div>\n</div>\n') }]), angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run(["$templateCache", function (a) { a.put("template/tooltip/tooltip-html-unsafe-popup.html", '<div class="tooltip"\n  tooltip-animation-class="fade"\n  tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" bind-html-unsafe="content"></div>\n</div>\n') }]), angular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function (a) { a.put("template/tooltip/tooltip-popup.html", '<div class="tooltip"\n  tooltip-animation-class="fade"\n  tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" ng-bind="content"></div>\n</div>\n') }]), angular.module("template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function (a) { a.put("template/tooltip/tooltip-template-popup.html", '<div class="tooltip"\n  tooltip-animation-class="fade"\n  tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner"\n    tooltip-template-transclude="contentExp()"\n    tooltip-template-transclude-scope="originScope()"></div>\n</div>\n') }]), angular.module("template/popover/popover-template.html", []).run(["$templateCache", function (a) { a.put("template/popover/popover-template.html", '<div class="popover"\n  tooltip-animation-class="fade"\n  tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="arrow"></div>\n\n  <div class="popover-inner">\n      <h3 class="popover-title" ng-bind="title" ng-if="title"></h3>\n      <div class="popover-content"\n        tooltip-template-transclude="contentExp()"\n        tooltip-template-transclude-scope="originScope()"></div>\n  </div>\n</div>\n') }]), angular.module("template/popover/popover-window.html", []).run(["$templateCache", function (a) { a.put("template/popover/popover-window.html", '<div class="popover {{placement}}" ng-class="{ in: isOpen, fade: animation }">\n  <div class="arrow"></div>\n\n  <div class="popover-inner">\n      <h3 class="popover-title" ng-bind="title" ng-show="title"></h3>\n      <div class="popover-content" tooltip-template-transclude></div>\n  </div>\n</div>\n') }]), angular.module("template/popover/popover.html", []).run(["$templateCache", function (a) { a.put("template/popover/popover.html", '<div class="popover"\n  tooltip-animation-class="fade"\n  tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="arrow"></div>\n\n  <div class="popover-inner">\n      <h3 class="popover-title" ng-bind="title" ng-if="title"></h3>\n      <div class="popover-content" ng-bind="content"></div>\n  </div>\n</div>\n') }]), angular.module("template/progressbar/bar.html", []).run(["$templateCache", function (a) { a.put("template/progressbar/bar.html", '<div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" ng-transclude></div>\n') }]), angular.module("template/progressbar/progress.html", []).run(["$templateCache", function (a) { a.put("template/progressbar/progress.html", '<div class="progress" ng-transclude></div>') }]), angular.module("template/progressbar/progressbar.html", []).run(["$templateCache", function (a) { a.put("template/progressbar/progressbar.html", '<div class="progress">\n  <div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" ng-transclude></div>\n</div>\n') }]), angular.module("template/rating/rating.html", []).run(["$templateCache", function (a) { a.put("template/rating/rating.html", '<span ng-mouseleave="reset()" ng-keydown="onKeydown($event)" tabindex="0" role="slider" aria-valuemin="0" aria-valuemax="{{range.length}}" aria-valuenow="{{value}}">\n    <i ng-repeat="r in range track by $index" ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < value && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')">\n        <span class="sr-only">({{ $index < value ? \'*\' : \' \' }})</span>\n    </i>\n</span>') }]), angular.module("template/tabs/tab.html", []).run(["$templateCache", function (a) { a.put("template/tabs/tab.html", '<li ng-class="{active: active, disabled: disabled}">\n  <a href ng-click="select()" tab-heading-transclude>{{heading}}</a>\n</li>\n') }]), angular.module("template/tabs/tabset.html", []).run(["$templateCache", function (a) { a.put("template/tabs/tabset.html", '<div>\n  <ul class="nav nav-{{type || \'tabs\'}}" ng-class="{\'nav-stacked\': vertical, \'nav-justified\': justified}" ng-transclude></ul>\n  <div class="tab-content">\n    <div class="tab-pane" \n         ng-repeat="tab in tabs" \n         ng-class="{active: tab.active}"\n         tab-content-transclude="tab">\n    </div>\n  </div>\n</div>\n') }]), angular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function (a) { a.put("template/timepicker/timepicker.html", '<table>\n	<tbody>\n		<tr class="text-center">\n			<td><a ng-click="incrementHours()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n			<td>&nbsp;</td>\n			<td><a ng-click="incrementMinutes()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n			<td ng-show="showMeridian"></td>\n		</tr>\n		<tr>\n			<td class="form-group" ng-class="{\'has-error\': invalidHours}">\n				<input style="width:50px;" type="text" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-readonly="readonlyInput" maxlength="2">\n			</td>\n			<td>:</td>\n			<td class="form-group" ng-class="{\'has-error\': invalidMinutes}">\n				<input style="width:50px;" type="text" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="readonlyInput" maxlength="2">\n			</td>\n			<td ng-show="showMeridian"><button type="button" class="btn btn-default text-center" ng-click="toggleMeridian()">{{meridian}}</button></td>\n		</tr>\n		<tr class="text-center">\n			<td><a ng-click="decrementHours()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n			<td>&nbsp;</td>\n			<td><a ng-click="decrementMinutes()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n			<td ng-show="showMeridian"></td>\n		</tr>\n	</tbody>\n</table>\n') }]), angular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function (a) { a.put("template/typeahead/typeahead-match.html", '<a tabindex="-1" bind-html-unsafe="match.label | typeaheadHighlight:query"></a>') }]), angular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function (a) { a.put("template/typeahead/typeahead-popup.html", '<ul class="dropdown-menu" ng-show="isOpen()" ng-style="{top: position.top+\'px\', left: position.left+\'px\'}" style="display: block;" role="listbox" aria-hidden="{{!isOpen()}}">\n    <li ng-repeat="match in matches track by $index" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index)" role="option" id="{{match.id}}">\n        <div typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n    </li>\n</ul>\n') }]), !angular.$$csp() && angular.element(document).find("head").prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');



angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.transition", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.position", "ui.bootstrap.datepicker", "ui.bootstrap.dialog", "ui.bootstrap.dropdownToggle", "ui.bootstrap.modal", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead"]);
angular.module("ui.bootstrap.tpls", ["template/accordion/accordion-group.html", "template/accordion/accordion.html", "template/alert/alert.html", "template/carousel/carousel.html", "template/carousel/slide.html", "template/datepicker/datepicker.html", "template/datepicker/popup.html", "template/dialog/message.html", "template/pagination/pager.html", "template/pagination/pagination.html", "template/tooltip/tooltip-html-unsafe-popup.html", "template/tooltip/tooltip-popup.html", "template/popover/popover.html", "template/progressbar/bar.html", "template/progressbar/progress.html", "template/rating/rating.html", "template/tabs/tab.html", "template/tabs/tabset-titles.html", "template/tabs/tabset.html", "template/timepicker/timepicker.html", "template/typeahead/typeahead-match.html", "template/typeahead/typeahead-popup.html"]);
angular.module('ui.bootstrap.transition', [])

/**
 * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.
 * @param  {DOMElement} element  The DOMElement that will be animated.
 * @param  {string|object|function} trigger  The thing that will cause the transition to start:
 *   - As a string, it represents the css class to be added to the element.
 *   - As an object, it represents a hash of style attributes to be applied to the element.
 *   - As a function, it represents a function to be called that will cause the transition to occur.
 * @return {Promise}  A promise that is resolved when the transition finishes.
 */
.factory('$transition', ['$q', '$timeout', '$rootScope', function ($q, $timeout, $rootScope) {

    var $transition = function (element, trigger, options) {
        options = options || {};
        var deferred = $q.defer();
        var endEventName = $transition[options.animation ? "animationEndEventName" : "transitionEndEventName"];

        var transitionEndHandler = function (event) {
            $rootScope.$apply(function () {
                element.unbind(endEventName, transitionEndHandler);
                deferred.resolve(element);
            });
        };

        if (endEventName) {
            element.bind(endEventName, transitionEndHandler);
        }

        // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur
        $timeout(function () {
            if (angular.isString(trigger)) {
                element.addClass(trigger);
            } else if (angular.isFunction(trigger)) {
                trigger(element);
            } else if (angular.isObject(trigger)) {
                element.css(trigger);
            }
            //If browser does not support transitions, instantly resolve
            if (!endEventName) {
                deferred.resolve(element);
            }
        });

        // Add our custom cancel function to the promise that is returned
        // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,
        // i.e. it will therefore never raise a transitionEnd event for that transition
        deferred.promise.cancel = function () {
            if (endEventName) {
                element.unbind(endEventName, transitionEndHandler);
            }
            deferred.reject('Transition cancelled');
        };

        return deferred.promise;
    };

    // Work out the name of the transitionEnd event
    var transElement = document.createElement('trans');
    var transitionEndEventNames = {
        'WebkitTransition': 'webkitTransitionEnd',
        'MozTransition': 'transitionend',
        'OTransition': 'oTransitionEnd',
        'transition': 'transitionend'
    };
    var animationEndEventNames = {
        'WebkitTransition': 'webkitAnimationEnd',
        'MozTransition': 'animationend',
        'OTransition': 'oAnimationEnd',
        'transition': 'animationend'
    };
    function findEndEventName(endEventNames) {
        for (var name in endEventNames) {
            if (transElement.style[name] !== undefined) {
                return endEventNames[name];
            }
        }
    }
    $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
    $transition.animationEndEventName = findEndEventName(animationEndEventNames);
    return $transition;
}]);

angular.module('ui.bootstrap.collapse', ['ui.bootstrap.transition'])

// The collapsible directive indicates a block of html that will expand and collapse
.directive('collapse', ['$transition', function ($transition) {
    // CSS transitions don't work with height: auto, so we have to manually change the height to a
    // specific value and then once the animation completes, we can reset the height to auto.
    // Unfortunately if you do this while the CSS transitions are specified (i.e. in the CSS class
    // "collapse") then you trigger a change to height 0 in between.
    // The fix is to remove the "collapse" CSS class while changing the height back to auto - phew!
    var fixUpHeight = function (scope, element, height) {
        // We remove the collapse CSS class to prevent a transition when we change to height: auto
        element.removeClass('collapse');
        element.css({ height: height });
        // It appears that  reading offsetWidth makes the browser realise that we have changed the
        // height already :-/
        var x = element[0].offsetWidth;
        element.addClass('collapse');
    };

    return {
        link: function (scope, element, attrs) {

            var isCollapsed;
            var initialAnimSkip = true;
            scope.$watch(function () { return element[0].scrollHeight; }, function (value) {
                //The listener is called when scollHeight changes
                //It actually does on 2 scenarios: 
                // 1. Parent is set to display none
                // 2. angular bindings inside are resolved
                //When we have a change of scrollHeight we are setting again the correct height if the group is opened
                if (element[0].scrollHeight !== 0) {
                    if (!isCollapsed) {
                        if (initialAnimSkip) {
                            fixUpHeight(scope, element, element[0].scrollHeight + 'px');
                        } else {
                            fixUpHeight(scope, element, 'auto');
                        }
                    }
                }
            });

            scope.$watch(attrs.collapse, function (value) {
                if (value) {
                    collapse();
                } else {
                    expand();
                }
            });


            var currentTransition;
            var doTransition = function (change) {
                if (currentTransition) {
                    currentTransition.cancel();
                }
                currentTransition = $transition(element, change);
                currentTransition.then(
                  function () { currentTransition = undefined; },
                  function () { currentTransition = undefined; }
                );
                return currentTransition;
            };

            var expand = function () {
                if (initialAnimSkip) {
                    initialAnimSkip = false;
                    if (!isCollapsed) {
                        fixUpHeight(scope, element, 'auto');
                    }
                } else {
                    doTransition({ height: element[0].scrollHeight + 'px' })
                    .then(function () {
                        // This check ensures that we don't accidentally update the height if the user has closed
                        // the group while the animation was still running
                        if (!isCollapsed) {
                            fixUpHeight(scope, element, 'auto');
                        }
                    });
                }
                isCollapsed = false;
            };

            var collapse = function () {
                isCollapsed = true;
                if (initialAnimSkip) {
                    initialAnimSkip = false;
                    fixUpHeight(scope, element, 0);
                } else {
                    fixUpHeight(scope, element, element[0].scrollHeight + 'px');
                    doTransition({ 'height': '0' });
                }
            };
        }
    };
}]);

angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])

.constant('accordionConfig', {
    closeOthers: true
})

.controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function ($scope, $attrs, accordionConfig) {

    // This array keeps track of the accordion groups
    this.groups = [];

    // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
    this.closeOthers = function (openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
        if (closeOthers) {
            angular.forEach(this.groups, function (group) {
                if (group !== openGroup) {
                    group.isOpen = false;
                }
            });
        }
    };

    // This is called from the accordion-group directive to add itself to the accordion
    this.addGroup = function (groupScope) {
        var that = this;
        this.groups.push(groupScope);

        groupScope.$on('$destroy', function (event) {
            that.removeGroup(groupScope);
        });
    };

    // This is called from the accordion-group directive when to remove itself
    this.removeGroup = function (group) {
        var index = this.groups.indexOf(group);
        if (index !== -1) {
            this.groups.splice(this.groups.indexOf(group), 1);
        }
    };

}])

// The accordion directive simply sets up the directive controller
// and adds an accordion CSS class to itself element.
.directive('accordion', function () {
    return {
        restrict: 'EA',
        controller: 'AccordionController',
        transclude: true,
        replace: false,
        templateUrl: 'template/accordion/accordion.html'
    };
})

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
.directive('accordionGroup', ['$parse', '$transition', '$timeout', function ($parse, $transition, $timeout) {
    return {
        require: '^accordion',         // We need this directive to be inside an accordion
        restrict: 'EA',
        transclude: true,              // It transcludes the contents of the directive into the template
        replace: true,                // The element containing the directive will be replaced with the template
        templateUrl: 'template/accordion/accordion-group.html',
        scope: { heading: '@' },        // Create an isolated scope and interpolate the heading attribute onto this scope
        controller: ['$scope', function ($scope) {
            this.setHeading = function (element) {
                this.heading = element;
            };
        }],
        link: function (scope, element, attrs, accordionCtrl) {
            var getIsOpen, setIsOpen;

            accordionCtrl.addGroup(scope);

            scope.isOpen = false;

            if (attrs.isOpen) {
                getIsOpen = $parse(attrs.isOpen);
                setIsOpen = getIsOpen.assign;

                scope.$watch(
                  function watchIsOpen() { return getIsOpen(scope.$parent); },
                  function updateOpen(value) { scope.isOpen = value; }
                );

                scope.isOpen = getIsOpen ? getIsOpen(scope.$parent) : false;
            }

            scope.$watch('isOpen', function (value) {
                if (value) {
                    accordionCtrl.closeOthers(scope);
                }
                if (setIsOpen) {
                    setIsOpen(scope.$parent, value);
                }
            });
        }
    };
}])

// Use accordion-heading below an accordion-group to provide a heading containing HTML
// <accordion-group>
//   <accordion-heading>Heading containing HTML - <img src="..."></accordion-heading>
// </accordion-group>
.directive('accordionHeading', function () {
    return {
        restrict: 'EA',
        transclude: true,   // Grab the contents to be used as the heading
        template: '',       // In effect remove this element!
        replace: true,
        require: '^accordionGroup',
        compile: function (element, attr, transclude) {
            return function link(scope, element, attr, accordionGroupCtrl) {
                // Pass the heading to the accordion-group controller
                // so that it can be transcluded into the right place in the template
                // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
                accordionGroupCtrl.setHeading(transclude(scope, function () { }));
            };
        }
    };
})

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
// <div class="accordion-group">
//   <div class="accordion-heading" ><a ... accordion-transclude="heading">...</a></div>
//   ...
// </div>
.directive('accordionTransclude', function () {
    return {
        require: '^accordionGroup',
        link: function (scope, element, attr, controller) {
            scope.$watch(function () { return controller[attr.accordionTransclude]; }, function (heading) {
                if (heading) {
                    element.html('');
                    element.append(heading);
                }
            });
        }
    };
});

angular.module("ui.bootstrap.alert", []).directive('alert', function () {
    return {
        restrict: 'EA',
        templateUrl: 'template/alert/alert.html',
        transclude: true,
        replace: true,
        scope: {
            type: '=',
            close: '&'
        },
        link: function (scope, iElement, iAttrs, controller) {
            scope.closeable = "close" in iAttrs;
        }
    };
});

angular.module('ui.bootstrap.buttons', [])

  .constant('buttonConfig', {
      activeClass: 'active',
      toggleEvent: 'click'
  })

  .directive('btnRadio', ['buttonConfig', function (buttonConfig) {
      var activeClass = buttonConfig.activeClass || 'active';
      var toggleEvent = buttonConfig.toggleEvent || 'click';

      return {

          require: 'ngModel',
          link: function (scope, element, attrs, ngModelCtrl) {

              //model -> UI
              ngModelCtrl.$render = function () {
                  element.toggleClass(activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
              };

              //ui->model
              element.bind(toggleEvent, function () {
                  if (!element.hasClass(activeClass)) {
                      scope.$apply(function () {
                          ngModelCtrl.$setViewValue(scope.$eval(attrs.btnRadio));
                          ngModelCtrl.$render();
                      });
                  }
              });
          }
      };
  }])

  .directive('btnCheckbox', ['buttonConfig', function (buttonConfig) {

      var activeClass = buttonConfig.activeClass || 'active';
      var toggleEvent = buttonConfig.toggleEvent || 'click';

      return {
          require: 'ngModel',
          link: function (scope, element, attrs, ngModelCtrl) {

              function getTrueValue() {
                  var trueValue = scope.$eval(attrs.btnCheckboxTrue);
                  return angular.isDefined(trueValue) ? trueValue : true;
              }

              function getFalseValue() {
                  var falseValue = scope.$eval(attrs.btnCheckboxFalse);
                  return angular.isDefined(falseValue) ? falseValue : false;
              }

              //model -> UI
              ngModelCtrl.$render = function () {
                  element.toggleClass(activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
              };

              //ui->model
              element.bind(toggleEvent, function () {
                  scope.$apply(function () {
                      ngModelCtrl.$setViewValue(element.hasClass(activeClass) ? getFalseValue() : getTrueValue());
                      ngModelCtrl.$render();
                  });
              });
          }
      };
  }]);
/**
* @ngdoc overview
* @name ui.bootstrap.carousel
* 
* @description
* AngularJS version of an image carousel.
*
*/
angular.module('ui.bootstrap.carousel', ['ui.bootstrap.transition'])
.controller('CarouselController', ['$scope', '$timeout', '$transition', '$q', function ($scope, $timeout, $transition, $q) {
    var self = this,
      slides = self.slides = [],
      currentIndex = -1,
      currentTimeout, isPlaying;
    self.currentSlide = null;

    /* direction: "prev" or "next" */
    self.select = function (nextSlide, direction) {
        var nextIndex = slides.indexOf(nextSlide);
        //Decide direction if it's not given
        if (direction === undefined) {
            direction = nextIndex > currentIndex ? "next" : "prev";
        }
        if (nextSlide && nextSlide !== self.currentSlide) {
            if ($scope.$currentTransition) {
                $scope.$currentTransition.cancel();
                //Timeout so ng-class in template has time to fix classes for finished slide
                $timeout(goNext);
            } else {
                goNext();
            }
        }
        function goNext() {
            //If we have a slide to transition from and we have a transition type and we're allowed, go
            if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) {
                //We shouldn't do class manip in here, but it's the same weird thing bootstrap does. need to fix sometime
                nextSlide.$element.addClass(direction);
                nextSlide.$element[0].offsetWidth = nextSlide.$element[0].offsetWidth; //force reflow

                //Set all other slides to stop doing their stuff for the new transition
                angular.forEach(slides, function (slide) {
                    angular.extend(slide, { direction: '', entering: false, leaving: false, active: false });
                });
                angular.extend(nextSlide, { direction: direction, active: true, entering: true });
                angular.extend(self.currentSlide || {}, { direction: direction, leaving: true });

                $scope.$currentTransition = $transition(nextSlide.$element, {});
                //We have to create new pointers inside a closure since next & current will change
                (function (next, current) {
                    $scope.$currentTransition.then(
                      function () { transitionDone(next, current); },
                      function () { transitionDone(next, current); }
                    );
                }(nextSlide, self.currentSlide));
            } else {
                transitionDone(nextSlide, self.currentSlide);
            }
            self.currentSlide = nextSlide;
            currentIndex = nextIndex;
            //every time you change slides, reset the timer
            restartTimer();
        }
        function transitionDone(next, current) {
            angular.extend(next, { direction: '', active: true, leaving: false, entering: false });
            angular.extend(current || {}, { direction: '', active: false, leaving: false, entering: false });
            $scope.$currentTransition = null;
        }
    };

    /* Allow outside people to call indexOf on slides array */
    self.indexOfSlide = function (slide) {
        return slides.indexOf(slide);
    };

    $scope.next = function () {
        var newIndex = (currentIndex + 1) % slides.length;

        //Prevent this user-triggered transition from occurring if there is already one in progress
        if (!$scope.$currentTransition) {
            return self.select(slides[newIndex], 'next');
        }
    };

    $scope.prev = function () {
        var newIndex = currentIndex - 1 < 0 ? slides.length - 1 : currentIndex - 1;

        //Prevent this user-triggered transition from occurring if there is already one in progress
        if (!$scope.$currentTransition) {
            return self.select(slides[newIndex], 'prev');
        }
    };

    $scope.select = function (slide) {
        self.select(slide);
    };

    $scope.isActive = function (slide) {
        return self.currentSlide === slide;
    };

    $scope.slides = function () {
        return slides;
    };

    $scope.$watch('interval', restartTimer);
    function restartTimer() {
        if (currentTimeout) {
            $timeout.cancel(currentTimeout);
        }
        function go() {
            if (isPlaying) {
                $scope.next();
                restartTimer();
            } else {
                $scope.pause();
            }
        }
        var interval = +$scope.interval;
        if (!isNaN(interval) && interval >= 0) {
            currentTimeout = $timeout(go, interval);
        }
    }
    $scope.play = function () {
        if (!isPlaying) {
            isPlaying = true;
            restartTimer();
        }
    };
    $scope.pause = function () {
        if (!$scope.noPause) {
            isPlaying = false;
            if (currentTimeout) {
                $timeout.cancel(currentTimeout);
            }
        }
    };

    self.addSlide = function (slide, element) {
        slide.$element = element;
        slides.push(slide);
        //if this is the first slide or the slide is set to active, select it
        if (slides.length === 1 || slide.active) {
            self.select(slides[slides.length - 1]);
            if (slides.length == 1) {
                $scope.play();
            }
        } else {
            slide.active = false;
        }
    };

    self.removeSlide = function (slide) {
        //get the index of the slide inside the carousel
        var index = slides.indexOf(slide);
        slides.splice(index, 1);
        if (slides.length > 0 && slide.active) {
            if (index >= slides.length) {
                self.select(slides[index - 1]);
            } else {
                self.select(slides[index]);
            }
        } else if (currentIndex > index) {
            currentIndex--;
        }
    };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:carousel
 * @restrict EA
 *
 * @description
 * Carousel is the outer container for a set of image 'slides' to showcase.
 *
 * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.
 * @param {boolean=} noTransition Whether to disable transitions on the carousel.
 * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <carousel>
      <slide>
        <img src="http://placekitten.com/150/150" style="margin:auto;">
        <div class="carousel-caption">
          <p>Beautiful!</p>
        </div>
      </slide>
      <slide>
        <img src="http://placekitten.com/100/150" style="margin:auto;">
        <div class="carousel-caption">
          <p>D'aww!</p>
        </div>
      </slide>
    </carousel>
  </file>
  <file name="demo.css">
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  </file>
</example>
 */
.directive('carousel', [function () {
    return {
        restrict: 'EA',
        transclude: true,
        replace: true,
        controller: 'CarouselController',
        require: 'carousel',
        templateUrl: 'template/carousel/carousel.html',
        scope: {
            interval: '=',
            noTransition: '=',
            noPause: '='
        }
    };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:slide
 * @restrict EA
 *
 * @description
 * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.
 *
 * @param {boolean=} active Model binding, whether or not this slide is currently active.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
<div ng-controller="CarouselDemoCtrl">
  <carousel>
    <slide ng-repeat="slide in slides" active="slide.active">
      <img ng-src="{{slide.image}}" style="margin:auto;">
      <div class="carousel-caption">
        <h4>Slide {{$index}}</h4>
        <p>{{slide.text}}</p>
      </div>
    </slide>
  </carousel>
  <div class="row-fluid">
    <div class="span6">
      <ul>
        <li ng-repeat="slide in slides">
          <button class="btn btn-mini" ng-class="{'btn-info': !slide.active, 'btn-success': slide.active}" ng-disabled="slide.active" ng-click="slide.active = true">select</button>
          {{$index}}: {{slide.text}}
        </li>
      </ul>
      <a class="btn" ng-click="addSlide()">Add Slide</a>
    </div>
    <div class="span6">
      Interval, in milliseconds: <input type="number" ng-model="myInterval">
      <br />Enter a negative number to stop the interval.
    </div>
  </div>
</div>
  </file>
  <file name="script.js">
function CarouselDemoCtrl($scope) {
  $scope.myInterval = 5000;
  var slides = $scope.slides = [];
  $scope.addSlide = function() {
    var newWidth = 200 + ((slides.length + (25 * slides.length)) % 150);
    slides.push({
      image: 'http://placekitten.com/' + newWidth + '/200',
      text: ['More','Extra','Lots of','Surplus'][slides.length % 4] + ' '
        ['Cats', 'Kittys', 'Felines', 'Cutes'][slides.length % 4]
    });
  };
  for (var i=0; i<4; i++) $scope.addSlide();
}
  </file>
  <file name="demo.css">
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  </file>
</example>
*/

.directive('slide', ['$parse', function ($parse) {
    return {
        require: '^carousel',
        restrict: 'EA',
        transclude: true,
        replace: true,
        templateUrl: 'template/carousel/slide.html',
        scope: {
        },
        link: function (scope, element, attrs, carouselCtrl) {
            //Set up optional 'active' = binding
            if (attrs.active) {
                var getActive = $parse(attrs.active);
                var setActive = getActive.assign;
                var lastValue = scope.active = getActive(scope.$parent);
                scope.$watch(function parentActiveWatch() {
                    var parentActive = getActive(scope.$parent);

                    if (parentActive !== scope.active) {
                        // we are out of sync and need to copy
                        if (parentActive !== lastValue) {
                            // parent changed and it has precedence
                            lastValue = scope.active = parentActive;
                        } else {
                            // if the parent can be assigned then do so
                            setActive(scope.$parent, parentActive = lastValue = scope.active);
                        }
                    }
                    return parentActive;
                });
            }

            carouselCtrl.addSlide(scope, element);
            //when the scope is destroyed then remove the slide from the current slides array
            scope.$on('$destroy', function () {
                carouselCtrl.removeSlide(scope);
            });

            scope.$watch('active', function (active) {
                if (active) {
                    carouselCtrl.select(scope);
                }
            });
        }
    };
}]);

angular.module('ui.bootstrap.position', [])

/**
 * A set of utility methods that can be use to retrieve position of DOM elements.
 * It is meant to be used where we need to absolute-position DOM elements in
 * relation to other, existing elements (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
  .factory('$position', ['$document', '$window', function ($document, $window) {

      var mouseX, mouseY;

      $document.bind('mousemove', function mouseMoved(event) {
          mouseX = event.pageX;
          mouseY = event.pageY;
      });

      function getStyle(el, cssprop) {
          if (el.currentStyle) { //IE
              return el.currentStyle[cssprop];
          } else if ($window.getComputedStyle) {
              return $window.getComputedStyle(el)[cssprop];
          }
          // finally try and get inline style
          return el.style[cssprop];
      }

      /**
       * Checks if a given element is statically positioned
       * @param element - raw DOM element
       */
      function isStaticPositioned(element) {
          return (getStyle(element, "position") || 'static') === 'static';
      }

      /**
       * returns the closest, non-statically positioned parentOffset of a given element
       * @param element
       */
      var parentOffsetEl = function (element) {
          var docDomEl = $document[0];
          var offsetParent = element.offsetParent || docDomEl;
          while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {
              offsetParent = offsetParent.offsetParent;
          }
          return offsetParent || docDomEl;
      };

      return {
          /**
           * Provides read-only equivalent of jQuery's position function:
           * http://api.jquery.com/position/
           */
          position: function (element) {
              var elBCR = this.offset(element);
              var offsetParentBCR = { top: 0, left: 0 };
              var offsetParentEl = parentOffsetEl(element[0]);
              if (offsetParentEl != $document[0]) {
                  offsetParentBCR = this.offset(angular.element(offsetParentEl));
                  offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
                  offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
              }

              return {
                  width: element.prop('offsetWidth'),
                  height: element.prop('offsetHeight'),
                  top: elBCR.top - offsetParentBCR.top,
                  left: elBCR.left - offsetParentBCR.left
              };
          },

          /**
           * Provides read-only equivalent of jQuery's offset function:
           * http://api.jquery.com/offset/
           */
          offset: function (element) {
              var boundingClientRect = element[0].getBoundingClientRect();
              return {
                  width: element.prop('offsetWidth'),
                  height: element.prop('offsetHeight'),
                  top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop),
                  left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft)
              };
          },

          /**
           * Provides the coordinates of the mouse
           */
          mouse: function () {
              return { x: mouseX, y: mouseY };
          }
      };
  }]);

angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.position'])

.constant('datepickerConfig', {
    dayFormat: 'dd',
    monthFormat: 'MMMM',
    yearFormat: 'yyyy',
    dayHeaderFormat: 'EEE',
    dayTitleFormat: 'MMMM yyyy',
    monthTitleFormat: 'yyyy',
    showWeeks: true,
    startingDay: 0,
    yearRange: 20,
    minDate: null,
    maxDate: null
})

.controller('DatepickerController', ['$scope', '$attrs', 'dateFilter', 'datepickerConfig', function ($scope, $attrs, dateFilter, dtConfig) {
    var format = {
        day: getValue($attrs.dayFormat, dtConfig.dayFormat),
        month: getValue($attrs.monthFormat, dtConfig.monthFormat),
        year: getValue($attrs.yearFormat, dtConfig.yearFormat),
        dayHeader: getValue($attrs.dayHeaderFormat, dtConfig.dayHeaderFormat),
        dayTitle: getValue($attrs.dayTitleFormat, dtConfig.dayTitleFormat),
        monthTitle: getValue($attrs.monthTitleFormat, dtConfig.monthTitleFormat)
    },
    startingDay = getValue($attrs.startingDay, dtConfig.startingDay),
    yearRange = getValue($attrs.yearRange, dtConfig.yearRange);

    this.minDate = dtConfig.minDate ? new Date(dtConfig.minDate) : null;
    this.maxDate = dtConfig.maxDate ? new Date(dtConfig.maxDate) : null;

    function getValue(value, defaultValue) {
        return angular.isDefined(value) ? $scope.$parent.$eval(value) : defaultValue;
    }

    function getDaysInMonth(year, month) {
        return new Date(year, month, 0).getDate();
    }

    function getDates(startDate, n) {
        var dates = new Array(n);
        var current = startDate, i = 0;
        while (i < n) {
            dates[i++] = new Date(current);
            current.setDate(current.getDate() + 1);
        }
        return dates;
    }

    function makeDate(date, format, isSelected, isSecondary) {
        return { date: date, label: dateFilter(date, format), selected: !!isSelected, secondary: !!isSecondary };
    }

    this.modes = [
      {
          name: 'day',
          getVisibleDates: function (date, selected) {
              var year = date.getFullYear(), month = date.getMonth(), firstDayOfMonth = new Date(year, month, 1);
              var difference = startingDay - firstDayOfMonth.getDay(),
              numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : -difference,
              firstDate = new Date(firstDayOfMonth), numDates = 0;

              if (numDisplayedFromPreviousMonth > 0) {
                  firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
                  numDates += numDisplayedFromPreviousMonth; // Previous
              }
              numDates += getDaysInMonth(year, month + 1); // Current
              numDates += (7 - numDates % 7) % 7; // Next

              var days = getDates(firstDate, numDates), labels = new Array(7);
              for (var i = 0; i < numDates; i++) {
                  var dt = new Date(days[i]);
                  days[i] = makeDate(dt, format.day, (selected && selected.getDate() === dt.getDate() && selected.getMonth() === dt.getMonth() && selected.getFullYear() === dt.getFullYear()), dt.getMonth() !== month);
              }
              for (var j = 0; j < 7; j++) {
                  labels[j] = dateFilter(days[j].date, format.dayHeader);
              }
              return { objects: days, title: dateFilter(date, format.dayTitle), labels: labels };
          },
          compare: function (date1, date2) {
              return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
          },
          split: 7,
          step: { months: 1 }
      },
      {
          name: 'month',
          getVisibleDates: function (date, selected) {
              var months = new Array(12), year = date.getFullYear();
              for (var i = 0; i < 12; i++) {
                  var dt = new Date(year, i, 1);
                  months[i] = makeDate(dt, format.month, (selected && selected.getMonth() === i && selected.getFullYear() === year));
              }
              return { objects: months, title: dateFilter(date, format.monthTitle) };
          },
          compare: function (date1, date2) {
              return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
          },
          split: 3,
          step: { years: 1 }
      },
      {
          name: 'year',
          getVisibleDates: function (date, selected) {
              var years = new Array(yearRange), year = date.getFullYear(), startYear = parseInt((year - 1) / yearRange, 10) * yearRange + 1;
              for (var i = 0; i < yearRange; i++) {
                  var dt = new Date(startYear + i, 0, 1);
                  years[i] = makeDate(dt, format.year, (selected && selected.getFullYear() === dt.getFullYear()));
              }
              return { objects: years, title: [years[0].label, years[yearRange - 1].label].join(' - ') };
          },
          compare: function (date1, date2) {
              return date1.getFullYear() - date2.getFullYear();
          },
          split: 5,
          step: { years: yearRange }
      }
    ];

    this.isDisabled = function (date, mode) {
        var currentMode = this.modes[mode || 0];
        return ((this.minDate && currentMode.compare(date, this.minDate) < 0) || (this.maxDate && currentMode.compare(date, this.maxDate) > 0) || ($scope.dateDisabled && $scope.dateDisabled({ date: date, mode: currentMode.name })));
    };
}])

.directive('datepicker', ['dateFilter', '$parse', 'datepickerConfig', '$log', function (dateFilter, $parse, datepickerConfig, $log) {
    return {
        restrict: 'EA',
        replace: true,
        templateUrl: 'template/datepicker/datepicker.html',
        scope: {
            dateDisabled: '&'
        },
        require: ['datepicker', '?^ngModel'],
        controller: 'DatepickerController',
        link: function (scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], ngModel = ctrls[1];

            if (!ngModel) {
                return; // do nothing if no ng-model
            }

            // Configuration parameters
            var mode = 0, selected = new Date(), showWeeks = datepickerConfig.showWeeks;

            if (attrs.showWeeks) {
                scope.$parent.$watch($parse(attrs.showWeeks), function (value) {
                    showWeeks = !!value;
                    updateShowWeekNumbers();
                });
            } else {
                updateShowWeekNumbers();
            }

            if (attrs.min) {
                scope.$parent.$watch($parse(attrs.min), function (value) {
                    datepickerCtrl.minDate = value ? new Date(value) : null;
                    refill();
                });
            }
            if (attrs.max) {
                scope.$parent.$watch($parse(attrs.max), function (value) {
                    datepickerCtrl.maxDate = value ? new Date(value) : null;
                    refill();
                });
            }

            function updateShowWeekNumbers() {
                scope.showWeekNumbers = mode === 0 && showWeeks;
            }

            // Split array into smaller arrays
            function split(arr, size) {
                var arrays = [];
                while (arr.length > 0) {
                    arrays.push(arr.splice(0, size));
                }
                return arrays;
            }

            function refill(updateSelected) {
                var date = null, valid = true;

                if (ngModel.$modelValue) {
                    date = new Date(ngModel.$modelValue);

                    if (isNaN(date)) {
                        valid = false;
                        $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
                    } else if (updateSelected) {
                        selected = date;
                    }
                }
                ngModel.$setValidity('date', valid);

                var currentMode = datepickerCtrl.modes[mode], data = currentMode.getVisibleDates(selected, date);
                angular.forEach(data.objects, function (obj) {
                    obj.disabled = datepickerCtrl.isDisabled(obj.date, mode);
                });

                ngModel.$setValidity('date-disabled', (!date || !datepickerCtrl.isDisabled(date)));

                scope.rows = split(data.objects, currentMode.split);
                scope.labels = data.labels || [];
                scope.title = data.title;
            }

            function setMode(value) {
                mode = value;
                updateShowWeekNumbers();
                refill();
            }

            ngModel.$render = function () {
                refill(true);
            };

            scope.select = function (date) {
                if (mode === 0) {
                    var dt = new Date(ngModel.$modelValue);
                    dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
                    ngModel.$setViewValue(dt);
                    refill(true);
                } else {
                    selected = date;
                    setMode(mode - 1);
                }
            };
            scope.move = function (direction) {
                var step = datepickerCtrl.modes[mode].step;
                selected.setMonth(selected.getMonth() + direction * (step.months || 0));
                selected.setFullYear(selected.getFullYear() + direction * (step.years || 0));
                refill();
            };
            scope.toggleMode = function () {
                setMode((mode + 1) % datepickerCtrl.modes.length);
            };
            scope.getWeekNumber = function (row) {
                return (mode === 0 && scope.showWeekNumbers && row.length === 7) ? getISO8601WeekNumber(row[0].date) : null;
            };

            function getISO8601WeekNumber(date) {
                var checkDate = new Date(date);
                checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
                var time = checkDate.getTime();
                checkDate.setMonth(0); // Compare with Jan 1
                checkDate.setDate(1);
                return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
            }
        }
    };
}])

.constant('datepickerPopupConfig', {
    dateFormat: 'yyyy-MM-dd',
    closeOnDateSelection: true
})

.directive('datepickerPopup', ['$compile', '$parse', '$document', '$position', 'dateFilter', 'datepickerPopupConfig',
function ($compile, $parse, $document, $position, dateFilter, datepickerPopupConfig) {
    return {
        restrict: 'EA',
        require: 'ngModel',
        link: function (originalScope, element, attrs, ngModel) {

            var closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;
            var dateFormat = attrs.datepickerPopup || datepickerPopupConfig.dateFormat;

            // create a child scope for the datepicker directive so we are not polluting original scope
            var scope = originalScope.$new();
            originalScope.$on('$destroy', function () {
                scope.$destroy();
            });

            function formatDate(value) {
                return (value) ? dateFilter(value, dateFormat) : null;
            }
            ngModel.$formatters.push(formatDate);

            // TODO: reverse from dateFilter string to Date object
            function parseDate(value) {
                if (value) {
                    var date = new Date(value);
                    if (!isNaN(date)) {
                        return date;
                    }
                }
                return value;
            }
            ngModel.$parsers.push(parseDate);

            var getIsOpen, setIsOpen;
            if (attrs.open) {
                getIsOpen = $parse(attrs.open);
                setIsOpen = getIsOpen.assign;

                originalScope.$watch(getIsOpen, function updateOpen(value) {
                    scope.isOpen = !!value;
                });
            }
            scope.isOpen = getIsOpen ? getIsOpen(originalScope) : false; // Initial state

            function setOpen(value) {
                if (setIsOpen) {
                    setIsOpen(originalScope, !!value);
                } else {
                    scope.isOpen = !!value;
                }
            }

            var documentClickBind = function (event) {
                if (scope.isOpen && event.target !== element[0]) {
                    scope.$apply(function () {
                        setOpen(false);
                    });
                }
            };

            var elementFocusBind = function () {
                scope.$apply(function () {
                    setOpen(true);
                });
            };

            // popup element used to display calendar
            var popupEl = angular.element('<datepicker-popup-wrap><datepicker></datepicker></datepicker-popup-wrap>');
            popupEl.attr({
                'ng-model': 'date',
                'ng-change': 'dateSelection()'
            });
            var datepickerEl = popupEl.find('datepicker');
            if (attrs.datepickerOptions) {
                datepickerEl.attr(angular.extend({}, originalScope.$eval(attrs.datepickerOptions)));
            }

            var $setModelValue = $parse(attrs.ngModel).assign;

            // Inner change
            scope.dateSelection = function () {
                $setModelValue(originalScope, scope.date);
                if (closeOnDateSelection) {
                    setOpen(false);
                }
            };

            // Outter change
            scope.$watch(function () {
                return ngModel.$modelValue;
            }, function (value) {
                if (angular.isString(value)) {
                    var date = parseDate(value);

                    if (value && !date) {
                        $setModelValue(originalScope, null);
                        throw new Error(value + ' cannot be parsed to a date object.');
                    } else {
                        value = date;
                    }
                }
                scope.date = value;
                updatePosition();
            });

            function addWatchableAttribute(attribute, scopeProperty, datepickerAttribute) {
                if (attribute) {
                    originalScope.$watch($parse(attribute), function (value) {
                        scope[scopeProperty] = value;
                    });
                    datepickerEl.attr(datepickerAttribute || scopeProperty, scopeProperty);
                }
            }
            addWatchableAttribute(attrs.min, 'min');
            addWatchableAttribute(attrs.max, 'max');
            if (attrs.showWeeks) {
                addWatchableAttribute(attrs.showWeeks, 'showWeeks', 'show-weeks');
            } else {
                scope.showWeeks = true;
                datepickerEl.attr('show-weeks', 'showWeeks');
            }
            if (attrs.dateDisabled) {
                datepickerEl.attr('date-disabled', attrs.dateDisabled);
            }

            function updatePosition() {
                scope.position = $position.position(element);
                scope.position.top = scope.position.top + element.prop('offsetHeight');
            }

            scope.$watch('isOpen', function (value) {
                if (value) {
                    updatePosition();
                    $document.bind('click', documentClickBind);
                    element.unbind('focus', elementFocusBind);
                    element.focus();
                } else {
                    $document.unbind('click', documentClickBind);
                    element.bind('focus', elementFocusBind);
                }

                if (setIsOpen) {
                    setIsOpen(originalScope, value);
                }
            });

            scope.today = function () {
                $setModelValue(originalScope, new Date());
            };
            scope.clear = function () {
                $setModelValue(originalScope, null);
            };

            element.after($compile(popupEl)(scope));
        }
    };
}])

.directive('datepickerPopupWrap', [function () {
    return {
        restrict: 'E',
        replace: true,
        transclude: true,
        templateUrl: 'template/datepicker/popup.html',
        link: function (scope, element, attrs) {
            element.bind('click', function (event) {
                event.preventDefault();
                event.stopPropagation();
            });
        }
    };
}]);
// The `$dialogProvider` can be used to configure global defaults for your
// `$dialog` service.
var dialogModule = angular.module('ui.bootstrap.dialog', ['ui.bootstrap.transition']);

dialogModule.controller('MessageBoxController', ['$scope', 'dialog', 'model', function ($scope, dialog, model) {
    $scope.title = model.title;
    $scope.message = model.message;
    $scope.buttons = model.buttons;
    $scope.close = function (res) {
        dialog.close(res);
    };
}]);

dialogModule.provider("$dialog", function () {

    // The default options for all dialogs.
    var defaults = {
        backdrop: true,
        dialogClass: 'modal',
        backdropClass: 'modal-backdrop',
        transitionClass: 'fade',
        triggerClass: 'in',
        resolve: {},
        backdropFade: false,
        dialogFade: false,
        keyboard: true, // close with esc key
        backdropClick: true // only in conjunction with backdrop=true
        /* other options: template, templateUrl, controller */
    };

    var globalOptions = {};

    var activeBackdrops = { value: 0 };

    // The `options({})` allows global configuration of all dialogs in the application.
    //
    //      var app = angular.module('App', ['ui.bootstrap.dialog'], function($dialogProvider){
    //        // don't close dialog when backdrop is clicked by default
    //        $dialogProvider.options({backdropClick: false});
    //      });
    this.options = function (value) {
        globalOptions = value;
    };

    // Returns the actual `$dialog` service that is injected in controllers
    this.$get = ["$http", "$document", "$compile", "$rootScope", "$controller", "$templateCache", "$q", "$transition", "$injector",
  function ($http, $document, $compile, $rootScope, $controller, $templateCache, $q, $transition, $injector) {

      var body = $document.find('body');

      function createElement(clazz) {
          var el = angular.element("<div>");
          el.addClass(clazz);
          return el;
      }

      // The `Dialog` class represents a modal dialog. The dialog class can be invoked by providing an options object
      // containing at lest template or templateUrl and controller:
      //
      //     var d = new Dialog({templateUrl: 'foo.html', controller: 'BarController'});
      //
      // Dialogs can also be created using templateUrl and controller as distinct arguments:
      //
      //     var d = new Dialog('path/to/dialog.html', MyDialogController);
      function Dialog(opts) {

          var self = this, options = this.options = angular.extend({}, defaults, globalOptions, opts);
          this._open = false;

          this.backdropEl = createElement(options.backdropClass);
          if (options.backdropFade) {
              this.backdropEl.addClass(options.transitionClass);
              this.backdropEl.removeClass(options.triggerClass);
          }

          this.modalEl = createElement(options.dialogClass);
          if (options.dialogFade) {
              this.modalEl.addClass(options.transitionClass);
              this.modalEl.removeClass(options.triggerClass);
          }

          this.handledEscapeKey = function (e) {
              if (e.which === 27) {
                  self.close();
                  e.preventDefault();
                  self.$scope.$apply();
              }
          };

          this.handleBackDropClick = function (e) {
              self.close();
              e.preventDefault();
              self.$scope.$apply();
          };
      }

      // The `isOpen()` method returns wether the dialog is currently visible.
      Dialog.prototype.isOpen = function () {
          return this._open;
      };

      // The `open(templateUrl, controller)` method opens the dialog.
      // Use the `templateUrl` and `controller` arguments if specifying them at dialog creation time is not desired.
      Dialog.prototype.open = function (templateUrl, controller) {
          var self = this, options = this.options;

          if (templateUrl) {
              options.templateUrl = templateUrl;
          }
          if (controller) {
              options.controller = controller;
          }

          if (!(options.template || options.templateUrl)) {
              throw new Error('Dialog.open expected template or templateUrl, neither found. Use options or open method to specify them.');
          }

          this._loadResolves().then(function (locals) {
              var $scope = locals.$scope = self.$scope = locals.$scope ? locals.$scope : $rootScope.$new();

              self.modalEl.html(locals.$template);

              if (self.options.controller) {
                  var ctrl = $controller(self.options.controller, locals);
                  self.modalEl.children().data('ngControllerController', ctrl);
              }

              $compile(self.modalEl)($scope);
              self._addElementsToDom();

              // trigger tranisitions
              setTimeout(function () {
                  if (self.options.dialogFade) { self.modalEl.addClass(self.options.triggerClass); }
                  if (self.options.backdropFade) { self.backdropEl.addClass(self.options.triggerClass); }
              });

              self._bindEvents();
          });

          this.deferred = $q.defer();
          return this.deferred.promise;
      };

      // closes the dialog and resolves the promise returned by the `open` method with the specified result.
      Dialog.prototype.close = function (result) {
          var self = this;
          var fadingElements = this._getFadingElements();

          if (fadingElements.length > 0) {
              for (var i = fadingElements.length - 1; i >= 0; i--) {
                  $transition(fadingElements[i], removeTriggerClass).then(onCloseComplete);
              }
              return;
          }

          this._onCloseComplete(result);

          function removeTriggerClass(el) {
              el.removeClass(self.options.triggerClass);
          }

          function onCloseComplete() {
              if (self._open) {
                  self._onCloseComplete(result);
              }
          }
      };

      Dialog.prototype._getFadingElements = function () {
          var elements = [];
          if (this.options.dialogFade) {
              elements.push(this.modalEl);
          }
          if (this.options.backdropFade) {
              elements.push(this.backdropEl);
          }

          return elements;
      };

      Dialog.prototype._bindEvents = function () {
          if (this.options.keyboard) { body.bind('keydown', this.handledEscapeKey); }
          if (this.options.backdrop && this.options.backdropClick) { this.backdropEl.bind('click', this.handleBackDropClick); }
      };

      Dialog.prototype._unbindEvents = function () {
          if (this.options.keyboard) { body.unbind('keydown', this.handledEscapeKey); }
          if (this.options.backdrop && this.options.backdropClick) { this.backdropEl.unbind('click', this.handleBackDropClick); }
      };

      Dialog.prototype._onCloseComplete = function (result) {
          this._removeElementsFromDom();
          this._unbindEvents();

          this.deferred.resolve(result);
      };

      Dialog.prototype._addElementsToDom = function () {
          body.append(this.modalEl);

          if (this.options.backdrop) {
              if (activeBackdrops.value === 0) {
                  body.append(this.backdropEl);
              }
              activeBackdrops.value++;
          }

          this._open = true;
      };

      Dialog.prototype._removeElementsFromDom = function () {
          this.modalEl.remove();

          if (this.options.backdrop) {
              activeBackdrops.value--;
              if (activeBackdrops.value === 0) {
                  this.backdropEl.remove();
              }
          }
          this._open = false;
      };

      // Loads all `options.resolve` members to be used as locals for the controller associated with the dialog.
      Dialog.prototype._loadResolves = function () {
          var values = [], keys = [], templatePromise, self = this;

          if (this.options.template) {
              templatePromise = $q.when(this.options.template);
          } else if (this.options.templateUrl) {
              templatePromise = $http.get(this.options.templateUrl, { cache: $templateCache })
              .then(function (response) { return response.data; });
          }

          angular.forEach(this.options.resolve || [], function (value, key) {
              keys.push(key);
              values.push(angular.isString(value) ? $injector.get(value) : $injector.invoke(value));
          });

          keys.push('$template');
          values.push(templatePromise);

          return $q.all(values).then(function (values) {
              var locals = {};
              angular.forEach(values, function (value, index) {
                  locals[keys[index]] = value;
              });
              locals.dialog = self;
              return locals;
          });
      };

      // The actual `$dialog` service that is injected in controllers.
      return {
          // Creates a new `Dialog` with the specified options.
          dialog: function (opts) {
              return new Dialog(opts);
          },
          // creates a new `Dialog` tied to the default message box template and controller.
          //
          // Arguments `title` and `message` are rendered in the modal header and body sections respectively.
          // The `buttons` array holds an object with the following members for each button to include in the
          // modal footer section:
          //
          // * `result`: the result to pass to the `close` method of the dialog when the button is clicked
          // * `label`: the label of the button
          // * `cssClass`: additional css class(es) to apply to the button for styling
          messageBox: function (title, message, buttons) {
              return new Dialog({
                  templateUrl: 'template/dialog/message.html', controller: 'MessageBoxController', resolve:
                    {
                        model: function () {
                            return {
                                title: title,
                                message: message,
                                buttons: buttons
                            };
                        }
                    }
              });
          }
      };
  }];
});

/*
 * dropdownToggle - Provides dropdown menu functionality in place of bootstrap js
 * @restrict class or attribute
 * @example:
   <li class="dropdown">
     <a class="dropdown-toggle">My Dropdown Menu</a>
     <ul class="dropdown-menu">
       <li ng-repeat="choice in dropChoices">
         <a ng-href="{{choice.href}}">{{choice.text}}</a>
       </li>
     </ul>
   </li>
 */

angular.module('ui.bootstrap.dropdownToggle', []).directive('dropdownToggle', ['$document', '$location', function ($document, $location) {
    var openElement = null,
        closeMenu = angular.noop;
    return {
        restrict: 'CA',
        link: function (scope, element, attrs) {
            scope.$watch('$location.path', function () { closeMenu(); });
            element.parent().bind('click', function () { closeMenu(); });
            element.bind('click', function (event) {

                var elementWasOpen = (element === openElement);

                event.preventDefault();
                event.stopPropagation();

                if (!!openElement) {
                    closeMenu();
                }

                if (!elementWasOpen) {
                    element.parent().addClass('open');
                    openElement = element;
                    closeMenu = function (event) {
                        if (event) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                        $document.unbind('click', closeMenu);
                        element.parent().removeClass('open');
                        closeMenu = angular.noop;
                        openElement = null;
                    };
                    $document.bind('click', closeMenu);
                }
            });
        }
    };
}]);
angular.module('ui.bootstrap.modal', ['ui.bootstrap.dialog'])
.directive('modal', ['$parse', '$dialog', function ($parse, $dialog) {
    return {
        restrict: 'EA',
        terminal: true,
        link: function (scope, elm, attrs) {
            var opts = angular.extend({}, scope.$eval(attrs.uiOptions || attrs.bsOptions || attrs.options));
            var shownExpr = attrs.modal || attrs.show;
            var setClosed;

            // Create a dialog with the template as the contents of the directive
            // Add the current scope as the resolve in order to make the directive scope as a dialog controller scope
            opts = angular.extend(opts, {
                template: elm.html(),
                resolve: { $scope: function () { return scope; } }
            });
            var dialog = $dialog.dialog(opts);

            elm.remove();

            if (attrs.close) {
                setClosed = function () {
                    $parse(attrs.close)(scope);
                };
            } else {
                setClosed = function () {
                    if (angular.isFunction($parse(shownExpr).assign)) {
                        $parse(shownExpr).assign(scope, false);
                    }
                };
            }

            scope.$watch(shownExpr, function (isShown, oldShown) {
                if (isShown) {
                    dialog.open().then(function () {
                        setClosed();
                    });
                } else {
                    //Make sure it is not opened
                    if (dialog.isOpen()) {
                        dialog.close();
                    }
                }
            });
        }
    };
}]);
angular.module('ui.bootstrap.pagination', [])

.controller('PaginationController', ['$scope', '$interpolate', function ($scope, $interpolate) {

    this.currentPage = 1;

    this.noPrevious = function () {
        return this.currentPage === 1;
    };
    this.noNext = function () {
        return this.currentPage === $scope.numPages;
    };

    this.isActive = function (page) {
        return this.currentPage === page;
    };

    this.reset = function () {
        $scope.pages = [];
        this.currentPage = parseInt($scope.currentPage, 10);

        if (this.currentPage > $scope.numPages) {
            $scope.selectPage($scope.numPages);
        }
    };

    var self = this;
    $scope.selectPage = function (page) {
        if (!self.isActive(page) && page > 0 && page <= $scope.numPages) {
            $scope.currentPage = page;
            $scope.onSelectPage({ page: page });
        }
    };

    this.getAttributeValue = function (attribute, defaultValue, interpolate) {
        return angular.isDefined(attribute) ? (interpolate ? $interpolate(attribute)($scope.$parent) : $scope.$parent.$eval(attribute)) : defaultValue;
    };
}])

.constant('paginationConfig', {
    boundaryLinks: false,
    directionLinks: true,
    firstText: 'First',
    previousText: 'Previous',
    nextText: 'Next',
    lastText: 'Last',
    rotate: true
})

.directive('pagination', ['paginationConfig', function (config) {
    return {
        restrict: 'EA',
        scope: {
            numPages: '=',
            currentPage: '=',
            maxSize: '=',
            onSelectPage: '&'
        },
        controller: 'PaginationController',
        templateUrl: 'template/pagination/pagination.html',
        replace: true,
        link: function (scope, element, attrs, paginationCtrl) {

            // Setup configuration parameters
            var boundaryLinks = paginationCtrl.getAttributeValue(attrs.boundaryLinks, config.boundaryLinks),
            directionLinks = paginationCtrl.getAttributeValue(attrs.directionLinks, config.directionLinks),
            firstText = paginationCtrl.getAttributeValue(attrs.firstText, config.firstText, true),
            previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, true),
            nextText = paginationCtrl.getAttributeValue(attrs.nextText, config.nextText, true),
            lastText = paginationCtrl.getAttributeValue(attrs.lastText, config.lastText, true),
            rotate = paginationCtrl.getAttributeValue(attrs.rotate, config.rotate);

            // Create page object used in template
            function makePage(number, text, isActive, isDisabled) {
                return {
                    number: number,
                    text: text,
                    active: isActive,
                    disabled: isDisabled
                };
            }

            scope.$watch('numPages + currentPage + maxSize', function () {
                paginationCtrl.reset();

                // Default page limits
                var startPage = 1, endPage = scope.numPages;
                var isMaxSized = (angular.isDefined(scope.maxSize) && scope.maxSize < scope.numPages);

                // recompute if maxSize
                if (isMaxSized) {
                    if (rotate) {
                        // Current page is displayed in the middle of the visible ones
                        startPage = Math.max(paginationCtrl.currentPage - Math.floor(scope.maxSize / 2), 1);
                        endPage = startPage + scope.maxSize - 1;

                        // Adjust if limit is exceeded
                        if (endPage > scope.numPages) {
                            endPage = scope.numPages;
                            startPage = endPage - scope.maxSize + 1;
                        }
                    } else {
                        // Visible pages are paginated with maxSize
                        startPage = ((Math.ceil(paginationCtrl.currentPage / scope.maxSize) - 1) * scope.maxSize) + 1;

                        // Adjust last page if limit is exceeded
                        endPage = Math.min(startPage + scope.maxSize - 1, scope.numPages);
                    }
                }

                // Add page number links
                for (var number = startPage; number <= endPage; number++) {
                    var page = makePage(number, number, paginationCtrl.isActive(number), false);
                    scope.pages.push(page);
                }

                // Add links to move between page sets
                if (isMaxSized && !rotate) {
                    if (startPage > 1) {
                        var previousPageSet = makePage(startPage - 1, '...', false, false);
                        scope.pages.unshift(previousPageSet);
                    }

                    if (endPage < scope.numPages) {
                        var nextPageSet = makePage(endPage + 1, '...', false, false);
                        scope.pages.push(nextPageSet);
                    }
                }

                // Add previous & next links
                if (directionLinks) {
                    var previousPage = makePage(paginationCtrl.currentPage - 1, previousText, false, paginationCtrl.noPrevious());
                    scope.pages.unshift(previousPage);

                    var nextPage = makePage(paginationCtrl.currentPage + 1, nextText, false, paginationCtrl.noNext());
                    scope.pages.push(nextPage);
                }

                // Add first & last links
                if (boundaryLinks) {
                    var firstPage = makePage(1, firstText, false, paginationCtrl.noPrevious());
                    scope.pages.unshift(firstPage);

                    var lastPage = makePage(scope.numPages, lastText, false, paginationCtrl.noNext());
                    scope.pages.push(lastPage);
                }
            });
        }
    };
}])

.constant('pagerConfig', {
    previousText: '« Previous',
    nextText: 'Next »',
    align: true
})

.directive('pager', ['pagerConfig', function (config) {
    return {
        restrict: 'EA',
        scope: {
            numPages: '=',
            currentPage: '=',
            onSelectPage: '&'
        },
        controller: 'PaginationController',
        templateUrl: 'template/pagination/pager.html',
        replace: true,
        link: function (scope, element, attrs, paginationCtrl) {

            // Setup configuration parameters
            var previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, true),
            nextText = paginationCtrl.getAttributeValue(attrs.nextText, config.nextText, true),
            align = paginationCtrl.getAttributeValue(attrs.align, config.align);

            // Create page object used in template
            function makePage(number, text, isDisabled, isPrevious, isNext) {
                return {
                    number: number,
                    text: text,
                    disabled: isDisabled,
                    previous: (align && isPrevious),
                    next: (align && isNext)
                };
            }

            scope.$watch('numPages + currentPage', function () {
                paginationCtrl.reset();

                // Add previous & next links
                var previousPage = makePage(paginationCtrl.currentPage - 1, previousText, paginationCtrl.noPrevious(), true, false);
                scope.pages.unshift(previousPage);

                var nextPage = makePage(paginationCtrl.currentPage + 1, nextText, paginationCtrl.noNext(), false, true);
                scope.pages.push(nextPage);
            });
        }
    };
}]);

/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position'])

/**
 * The $tooltip service creates tooltip- and popover-like directives as well as
 * houses global options for them.
 */
.provider('$tooltip', function () {
    // The default options tooltip and popover.
    var defaultOptions = {
        placement: 'top',
        animation: true,
        popupDelay: 0
    };

    // Default hide triggers for each show trigger
    var triggerMap = {
        'mouseenter': 'mouseleave',
        'click': 'click',
        'focus': 'blur'
    };

    // The options specified to the provider globally.
    var globalOptions = {};

    /**
     * `options({})` allows global configuration of all tooltips in the
     * application.
     *
     *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
     *     // place tooltips left instead of top by default
     *     $tooltipProvider.options( { placement: 'left' } );
     *   });
     */
    this.options = function (value) {
        angular.extend(globalOptions, value);
    };

    /**
     * This allows you to extend the set of trigger mappings available. E.g.:
     *
     *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
     */
    this.setTriggers = function setTriggers(triggers) {
        angular.extend(triggerMap, triggers);
    };

    /**
     * This is a helper function for translating camel-case to snake-case.
     */
    function snake_case(name) {
        var regexp = /[A-Z]/g;
        var separator = '-';
        return name.replace(regexp, function (letter, pos) {
            return (pos ? separator : '') + letter.toLowerCase();
        });
    }

    /**
     * Returns the actual instance of the $tooltip service.
     * TODO support multiple triggers
     */
    this.$get = ['$window', '$compile', '$timeout', '$parse', '$document', '$position', '$interpolate', function ($window, $compile, $timeout, $parse, $document, $position, $interpolate) {
        return function $tooltip(type, prefix, defaultTriggerShow) {
            var options = angular.extend({}, defaultOptions, globalOptions);

            /**
             * Returns an object of show and hide triggers.
             *
             * If a trigger is supplied,
             * it is used to show the tooltip; otherwise, it will use the `trigger`
             * option passed to the `$tooltipProvider.options` method; else it will
             * default to the trigger supplied to this directive factory.
             *
             * The hide trigger is based on the show trigger. If the `trigger` option
             * was passed to the `$tooltipProvider.options` method, it will use the
             * mapped trigger from `triggerMap` or the passed trigger if the map is
             * undefined; otherwise, it uses the `triggerMap` value of the show
             * trigger; else it will just use the show trigger.
             */
            function getTriggers(trigger) {
                var show = trigger || options.trigger || defaultTriggerShow;
                var hide = triggerMap[show] || show;
                return {
                    show: show,
                    hide: hide
                };
            }

            var directiveName = snake_case(type);

            var startSym = $interpolate.startSymbol();
            var endSym = $interpolate.endSymbol();
            var template =
              '<' + directiveName + '-popup ' +
                'title="' + startSym + 'tt_title' + endSym + '" ' +
                'content="' + startSym + 'tt_content' + endSym + '" ' +
                'placement="' + startSym + 'tt_placement' + endSym + '" ' +
                'animation="tt_animation()" ' +
                'is-open="tt_isOpen"' +
                '>' +
              '</' + directiveName + '-popup>';

            return {
                restrict: 'EA',
                scope: true,
                link: function link(scope, element, attrs) {
                    var tooltip = $compile(template)(scope);
                    var transitionTimeout;
                    var popupTimeout;
                    var $body;
                    var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
                    var triggers = getTriggers(undefined);
                    var hasRegisteredTriggers = false;

                    // By default, the tooltip is not open.
                    // TODO add ability to start tooltip opened
                    scope.tt_isOpen = false;

                    function toggleTooltipBind() {
                        if (!scope.tt_isOpen) {
                            showTooltipBind();
                        } else {
                            hideTooltipBind();
                        }
                    }

                    // Show the tooltip with delay if specified, otherwise show it immediately
                    function showTooltipBind() {
                        if (scope.tt_popupDelay) {
                            popupTimeout = $timeout(show, scope.tt_popupDelay);
                        } else {
                            scope.$apply(show);
                        }
                    }

                    function hideTooltipBind() {
                        scope.$apply(function () {
                            hide();
                        });
                    }

                    // Show the tooltip popup element.
                    function show() {
                        var position,
                            ttWidth,
                            ttHeight,
                            ttPosition;

                        // Don't show empty tooltips.
                        if (!scope.tt_content) {
                            return;
                        }

                        // If there is a pending remove transition, we must cancel it, lest the
                        // tooltip be mysteriously removed.
                        if (transitionTimeout) {
                            $timeout.cancel(transitionTimeout);
                        }

                        // Set the initial positioning.
                        tooltip.css({ top: 0, left: 0, display: 'block' });

                        // Now we add it to the DOM because need some info about it. But it's not 
                        // visible yet anyway.
                        if (appendToBody) {
                            $body = $body || $document.find('body');
                            $body.append(tooltip);
                        } else {
                            element.after(tooltip);
                        }

                        // Get the position of the directive element.
                        position = appendToBody ? $position.offset(element) : $position.position(element);

                        // Get the height and width of the tooltip so we can center it.
                        ttWidth = tooltip.prop('offsetWidth');
                        ttHeight = tooltip.prop('offsetHeight');

                        // Calculate the tooltip's top and left coordinates to center it with
                        // this directive.
                        switch (scope.tt_placement) {
                            case 'mouse':
                                var mousePos = $position.mouse();
                                ttPosition = {
                                    top: mousePos.y,
                                    left: mousePos.x
                                };
                                break;
                            case 'right':
                                ttPosition = {
                                    top: position.top + position.height / 2 - ttHeight / 2,
                                    left: position.left + position.width
                                };
                                break;
                            case 'bottom':
                                ttPosition = {
                                    top: position.top + position.height,
                                    left: position.left + position.width / 2 - ttWidth / 2
                                };
                                break;
                            case 'left':
                                ttPosition = {
                                    top: position.top + position.height / 2 - ttHeight / 2,
                                    left: position.left - ttWidth
                                };
                                break;
                            default:
                                ttPosition = {
                                    top: position.top - ttHeight,
                                    left: position.left + position.width / 2 - ttWidth / 2
                                };
                                break;
                        }

                        ttPosition.top += 'px';
                        ttPosition.left += 'px';

                        // Now set the calculated positioning.
                        tooltip.css(ttPosition);

                        // And show the tooltip.
                        scope.tt_isOpen = true;
                    }

                    // Hide the tooltip popup element.
                    function hide() {
                        // First things first: we don't show it anymore.
                        scope.tt_isOpen = false;

                        //if tooltip is going to be shown after delay, we must cancel this
                        $timeout.cancel(popupTimeout);

                        // And now we remove it from the DOM. However, if we have animation, we 
                        // need to wait for it to expire beforehand.
                        // FIXME: this is a placeholder for a port of the transitions library.
                        if (angular.isDefined(scope.tt_animation) && scope.tt_animation()) {
                            transitionTimeout = $timeout(function () { tooltip.remove(); }, 500);
                        } else {
                            tooltip.remove();
                        }
                    }

                    /**
                     * Observe the relevant attributes.
                     */
                    attrs.$observe(type, function (val) {
                        scope.tt_content = val;
                    });

                    attrs.$observe(prefix + 'Title', function (val) {
                        scope.tt_title = val;
                    });

                    attrs.$observe(prefix + 'Placement', function (val) {
                        scope.tt_placement = angular.isDefined(val) ? val : options.placement;
                    });

                    attrs.$observe(prefix + 'Animation', function (val) {
                        scope.tt_animation = angular.isDefined(val) ? $parse(val) : function () { return options.animation; };
                    });

                    attrs.$observe(prefix + 'PopupDelay', function (val) {
                        var delay = parseInt(val, 10);
                        scope.tt_popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                    });

                    attrs.$observe(prefix + 'Trigger', function (val) {

                        if (hasRegisteredTriggers) {
                            element.unbind(triggers.show, showTooltipBind);
                            element.unbind(triggers.hide, hideTooltipBind);
                        }

                        triggers = getTriggers(val);

                        if (triggers.show === triggers.hide) {
                            element.bind(triggers.show, toggleTooltipBind);
                        } else {
                            element.bind(triggers.show, showTooltipBind);
                            element.bind(triggers.hide, hideTooltipBind);
                        }

                        hasRegisteredTriggers = true;
                    });

                    attrs.$observe(prefix + 'AppendToBody', function (val) {
                        appendToBody = angular.isDefined(val) ? $parse(val)(scope) : appendToBody;
                    });

                    // if a tooltip is attached to <body> we need to remove it on
                    // location change as its parent scope will probably not be destroyed
                    // by the change.
                    if (appendToBody) {
                        scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {
                            if (scope.tt_isOpen) {
                                hide();
                            }
                        });
                    }

                    // Make sure tooltip is destroyed and removed.
                    scope.$on('$destroy', function onDestroyTooltip() {
                        if (scope.tt_isOpen) {
                            hide();
                        } else {
                            tooltip.remove();
                        }
                    });
                }
            };
        };
    }];
})

.directive('tooltipPopup', function () {
    return {
        restrict: 'E',
        replace: true,
        scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },
        templateUrl: 'template/tooltip/tooltip-popup.html'
    };
})

.directive('tooltip', ['$tooltip', function ($tooltip) {
    return $tooltip('tooltip', 'tooltip', 'mouseenter');
}])

.directive('tooltipHtmlUnsafePopup', function () {
    return {
        restrict: 'E',
        replace: true,
        scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },
        templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'
    };
})

.directive('tooltipHtmlUnsafe', ['$tooltip', function ($tooltip) {
    return $tooltip('tooltipHtmlUnsafe', 'tooltip', 'mouseenter');
}]);

/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html popovers, and selector delegatation.
 */
angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])
.directive('popoverPopup', function () {
    return {
        restrict: 'EA',
        replace: true,
        scope: { title: '@', content: '@', placement: '@', animation: '&', isOpen: '&' },
        templateUrl: 'template/popover/popover.html'
    };
})
.directive('popover', ['$compile', '$timeout', '$parse', '$window', '$tooltip', function ($compile, $timeout, $parse, $window, $tooltip) {
    return $tooltip('popover', 'popover', 'click');
}]);


angular.module('ui.bootstrap.progressbar', ['ui.bootstrap.transition'])

.constant('progressConfig', {
    animate: true,
    autoType: false,
    stackedTypes: ['success', 'info', 'warning', 'danger']
})

.controller('ProgressBarController', ['$scope', '$attrs', 'progressConfig', function ($scope, $attrs, progressConfig) {

    // Whether bar transitions should be animated
    var animate = angular.isDefined($attrs.animate) ? $scope.$eval($attrs.animate) : progressConfig.animate;
    var autoType = angular.isDefined($attrs.autoType) ? $scope.$eval($attrs.autoType) : progressConfig.autoType;
    var stackedTypes = angular.isDefined($attrs.stackedTypes) ? $scope.$eval('[' + $attrs.stackedTypes + ']') : progressConfig.stackedTypes;

    // Create bar object
    this.makeBar = function (newBar, oldBar, index) {
        var newValue = (angular.isObject(newBar)) ? newBar.value : (newBar || 0);
        var oldValue = (angular.isObject(oldBar)) ? oldBar.value : (oldBar || 0);
        var type = (angular.isObject(newBar) && angular.isDefined(newBar.type)) ? newBar.type : (autoType) ? getStackedType(index || 0) : null;

        return {
            from: oldValue,
            to: newValue,
            type: type,
            animate: animate
        };
    };

    function getStackedType(index) {
        return stackedTypes[index];
    }

    this.addBar = function (bar) {
        $scope.bars.push(bar);
        $scope.totalPercent += bar.to;
    };

    this.clearBars = function () {
        $scope.bars = [];
        $scope.totalPercent = 0;
    };
    this.clearBars();
}])

.directive('progress', function () {
    return {
        restrict: 'EA',
        replace: true,
        controller: 'ProgressBarController',
        scope: {
            value: '=percent',
            onFull: '&',
            onEmpty: '&'
        },
        templateUrl: 'template/progressbar/progress.html',
        link: function (scope, element, attrs, controller) {
            scope.$watch('value', function (newValue, oldValue) {
                controller.clearBars();

                if (angular.isArray(newValue)) {
                    // Stacked progress bar
                    for (var i = 0, n = newValue.length; i < n; i++) {
                        controller.addBar(controller.makeBar(newValue[i], oldValue[i], i));
                    }
                } else {
                    // Simple bar
                    controller.addBar(controller.makeBar(newValue, oldValue));
                }
            }, true);

            // Total percent listeners
            scope.$watch('totalPercent', function (value) {
                if (value >= 100) {
                    scope.onFull();
                } else if (value <= 0) {
                    scope.onEmpty();
                }
            }, true);
        }
    };
})

.directive('progressbar', ['$transition', function ($transition) {
    return {
        restrict: 'EA',
        replace: true,
        scope: {
            width: '=',
            old: '=',
            type: '=',
            animate: '='
        },
        templateUrl: 'template/progressbar/bar.html',
        link: function (scope, element) {
            scope.$watch('width', function (value) {
                if (scope.animate) {
                    element.css('width', scope.old + '%');
                    $transition(element, { width: value + '%' });
                } else {
                    element.css('width', value + '%');
                }
            });
        }
    };
}]);
angular.module('ui.bootstrap.rating', [])

.constant('ratingConfig', {
    max: 5
})

.directive('rating', ['ratingConfig', '$parse', function (ratingConfig, $parse) {
    return {
        restrict: 'EA',
        scope: {
            value: '=',
            onHover: '&',
            onLeave: '&'
        },
        templateUrl: 'template/rating/rating.html',
        replace: true,
        link: function (scope, element, attrs) {

            var maxRange = angular.isDefined(attrs.max) ? scope.$parent.$eval(attrs.max) : ratingConfig.max;

            scope.range = [];
            for (var i = 1; i <= maxRange; i++) {
                scope.range.push(i);
            }

            scope.rate = function (value) {
                if (!scope.readonly) {
                    scope.value = value;
                }
            };

            scope.enter = function (value) {
                if (!scope.readonly) {
                    scope.val = value;
                }
                scope.onHover({ value: value });
            };

            scope.reset = function () {
                scope.val = angular.copy(scope.value);
                scope.onLeave();
            };
            scope.reset();

            scope.$watch('value', function (value) {
                scope.val = value;
            });

            scope.readonly = false;
            if (attrs.readonly) {
                scope.$parent.$watch($parse(attrs.readonly), function (value) {
                    scope.readonly = !!value;
                });
            }
        }
    };
}]);

/**
 * @ngdoc overview
 * @name ui.bootstrap.tabs
 *
 * @description
 * AngularJS version of the tabs directive.
 */

angular.module('ui.bootstrap.tabs', [])

.directive('tabs', function () {
    return function () {
        throw new Error("The `tabs` directive is deprecated, please migrate to `tabset`. Instructions can be found at http://github.com/angular-ui/bootstrap/tree/master/CHANGELOG.md");
    };
})

.controller('TabsetController', ['$scope', '$element',
function TabsetCtrl($scope, $element) {

    var ctrl = this,
      tabs = ctrl.tabs = $scope.tabs = [];

    ctrl.select = function (tab) {
        angular.forEach(tabs, function (tab) {
            tab.active = false;
        });
        tab.active = true;
    };

    ctrl.addTab = function addTab(tab) {
        tabs.push(tab);
        if (tabs.length === 1 || tab.active) {
            ctrl.select(tab);
        }
    };

    ctrl.removeTab = function removeTab(tab) {
        var index = tabs.indexOf(tab);
        //Select a new tab if the tab to be removed is selected
        if (tab.active && tabs.length > 1) {
            //If this is the last tab, select the previous tab. else, the next tab.
            var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
            ctrl.select(tabs[newActiveIndex]);
        }
        tabs.splice(index, 1);
    };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabset
 * @restrict EA
 *
 * @description
 * Tabset is the outer container for the tabs directive
 *
 * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.
 * @param {string=} direction  What direction the tabs should be rendered. Available:
 * 'right', 'left', 'below'.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <tabset>
      <tab heading="Vertical Tab 1"><b>First</b> Content!</tab>
      <tab heading="Vertical Tab 2"><i>Second</i> Content!</tab>
    </tabset>
    <hr />
    <tabset vertical="true">
      <tab heading="Vertical Tab 1"><b>First</b> Vertical Content!</tab>
      <tab heading="Vertical Tab 2"><i>Second</i> Vertical Content!</tab>
    </tabset>
  </file>
</example>
 */
.directive('tabset', function () {
    return {
        restrict: 'EA',
        transclude: true,
        replace: true,
        require: '^tabset',
        scope: {},
        controller: 'TabsetController',
        templateUrl: 'template/tabs/tabset.html',
        compile: function (elm, attrs, transclude) {
            return function (scope, element, attrs, tabsetCtrl) {
                scope.vertical = angular.isDefined(attrs.vertical) ? scope.$eval(attrs.vertical) : false;
                scope.type = angular.isDefined(attrs.type) ? scope.$parent.$eval(attrs.type) : 'tabs';
                scope.direction = angular.isDefined(attrs.direction) ? scope.$parent.$eval(attrs.direction) : 'top';
                scope.tabsAbove = (scope.direction != 'below');
                tabsetCtrl.$scope = scope;
                tabsetCtrl.$transcludeFn = transclude;
            };
        }
    };
})

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tab
 * @restrict EA
 *
 * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.
 * @param {string=} select An expression to evaluate when the tab is selected.
 * @param {boolean=} active A binding, telling whether or not this tab is selected.
 * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.
 *
 * @description
 * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <div ng-controller="TabsDemoCtrl">
      <button class="btn btn-small" ng-click="items[0].active = true">
        Select item 1, using active binding
      </button>
      <button class="btn btn-small" ng-click="items[1].disabled = !items[1].disabled">
        Enable/disable item 2, using disabled binding
      </button>
      <br />
      <tabset>
        <tab heading="Tab 1">First Tab</tab>
        <tab select="alertMe()">
          <tab-heading><i class="icon-bell"></i> Alert me!</tab-heading>
          Second Tab, with alert callback and html heading!
        </tab>
        <tab ng-repeat="item in items"
          heading="{{item.title}}"
          disabled="item.disabled"
          active="item.active">
          {{item.content}}
        </tab>
      </tabset>
    </div>
  </file>
  <file name="script.js">
    function TabsDemoCtrl($scope) {
      $scope.items = [
        { title:"Dynamic Title 1", content:"Dynamic Item 0" },
        { title:"Dynamic Title 2", content:"Dynamic Item 1", disabled: true }
      ];

      $scope.alertMe = function() {
        setTimeout(function() {
          alert("You've selected the alert tab!");
        });
      };
    };
  </file>
</example>
 */

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabHeading
 * @restrict EA
 *
 * @description
 * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <tabset>
      <tab>
        <tab-heading><b>HTML</b> in my titles?!</tab-heading>
        And some content, too!
      </tab>
      <tab>
        <tab-heading><i class="icon-heart"></i> Icon heading?!?</tab-heading>
        That's right.
      </tab>
    </tabset>
  </file>
</example>
 */
.directive('tab', ['$parse', '$http', '$templateCache', '$compile',
function ($parse, $http, $templateCache, $compile) {
    return {
        require: '^tabset',
        restrict: 'EA',
        replace: true,
        templateUrl: 'template/tabs/tab.html',
        transclude: true,
        scope: {
            heading: '@',
            onSelect: '&select', //This callback is called in contentHeadingTransclude
            //once it inserts the tab's content into the dom
            onDeselect: '&deselect'
        },
        controller: function () {
            //Empty controller so other directives can require being 'under' a tab
        },
        compile: function (elm, attrs, transclude) {
            return function postLink(scope, elm, attrs, tabsetCtrl) {
                var getActive, setActive;
                if (attrs.active) {
                    getActive = $parse(attrs.active);
                    setActive = getActive.assign;
                    scope.$parent.$watch(getActive, function updateActive(value) {
                        scope.active = !!value;
                    });
                    scope.active = getActive(scope.$parent);
                } else {
                    setActive = getActive = angular.noop;
                }

                scope.$watch('active', function (active) {
                    setActive(scope.$parent, active);
                    if (active) {
                        tabsetCtrl.select(scope);
                        scope.onSelect();
                    } else {
                        scope.onDeselect();
                    }
                });

                scope.disabled = false;
                if (attrs.disabled) {
                    scope.$parent.$watch($parse(attrs.disabled), function (value) {
                        scope.disabled = !!value;
                    });
                }

                scope.select = function () {
                    if (!scope.disabled) {
                        scope.active = true;
                    }
                };

                tabsetCtrl.addTab(scope);
                scope.$on('$destroy', function () {
                    tabsetCtrl.removeTab(scope);
                });
                if (scope.active) {
                    setActive(scope.$parent, true);
                }


                //We need to transclude later, once the content container is ready.
                //when this link happens, we're inside a tab heading.
                scope.$transcludeFn = transclude;
            };
        }
    };
}])

.directive('tabHeadingTransclude', [function () {
    return {
        restrict: 'A',
        require: '^tab',
        link: function (scope, elm, attrs, tabCtrl) {
            scope.$watch('headingElement', function updateHeadingElement(heading) {
                if (heading) {
                    elm.html('');
                    elm.append(heading);
                }
            });
        }
    };
}])

.directive('tabContentTransclude', ['$compile', '$parse', function ($compile, $parse) {
    return {
        restrict: 'A',
        require: '^tabset',
        link: function (scope, elm, attrs) {
            var tab = scope.$eval(attrs.tabContentTransclude);

            //Now our tab is ready to be transcluded: both the tab heading area
            //and the tab content area are loaded.  Transclude 'em both.
            tab.$transcludeFn(tab.$parent, function (contents) {
                angular.forEach(contents, function (node) {
                    if (isTabHeading(node)) {
                        //Let tabHeadingTransclude know.
                        tab.headingElement = node;
                    } else {
                        elm.append(node);
                    }
                });
            });
        }
    };
    function isTabHeading(node) {
        return node.tagName && (
          node.hasAttribute('tab-heading') ||
          node.hasAttribute('data-tab-heading') ||
          node.tagName.toLowerCase() === 'tab-heading' ||
          node.tagName.toLowerCase() === 'data-tab-heading'
        );
    }
}])

.directive('tabsetTitles', function ($http) {
    return {
        restrict: 'A',
        require: '^tabset',
        templateUrl: 'template/tabs/tabset-titles.html',
        replace: true,
        link: function (scope, elm, attrs, tabsetCtrl) {
            if (!scope.$eval(attrs.tabsetTitles)) {
                elm.remove();
            } else {
                //now that tabs location has been decided, transclude the tab titles in
                tabsetCtrl.$transcludeFn(tabsetCtrl.$scope.$parent, function (node) {
                    elm.append(node);
                });
            }
        }
    };
})

;


angular.module('ui.bootstrap.timepicker', [])

.filter('pad', function () {
    return function (input) {
        if (angular.isDefined(input) && input.toString().length < 2) {
            input = '0' + input;
        }
        return input;
    };
})

.constant('timepickerConfig', {
    hourStep: 1,
    minuteStep: 1,
    showMeridian: true,
    meridians: ['AM', 'PM'],
    readonlyInput: false,
    mousewheel: true
})

.directive('timepicker', ['padFilter', '$parse', 'timepickerConfig', function (padFilter, $parse, timepickerConfig) {
    return {
        restrict: 'EA',
        require: 'ngModel',
        replace: true,
        templateUrl: 'template/timepicker/timepicker.html',
        scope: {
            model: '=ngModel'
        },
        link: function (scope, element, attrs, ngModelCtrl) {
            var selected = new Date(), meridians = timepickerConfig.meridians;

            var hourStep = timepickerConfig.hourStep;
            if (attrs.hourStep) {
                scope.$parent.$watch($parse(attrs.hourStep), function (value) {
                    hourStep = parseInt(value, 10);
                });
            }

            var minuteStep = timepickerConfig.minuteStep;
            if (attrs.minuteStep) {
                scope.$parent.$watch($parse(attrs.minuteStep), function (value) {
                    minuteStep = parseInt(value, 10);
                });
            }

            // 12H / 24H mode
            scope.showMeridian = timepickerConfig.showMeridian;
            if (attrs.showMeridian) {
                scope.$parent.$watch($parse(attrs.showMeridian), function (value) {
                    scope.showMeridian = !!value;

                    if (!scope.model) {
                        // Reset
                        var dt = new Date(selected);
                        var hours = getScopeHours();
                        if (angular.isDefined(hours)) {
                            dt.setHours(hours);
                        }
                        scope.model = new Date(dt);
                    } else {
                        refreshTemplate();
                    }
                });
            }

            // Get scope.hours in 24H mode if valid
            function getScopeHours() {
                var hours = parseInt(scope.hours, 10);
                var valid = (scope.showMeridian) ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);
                if (!valid) {
                    return;
                }

                if (scope.showMeridian) {
                    if (hours === 12) {
                        hours = 0;
                    }
                    if (scope.meridian === meridians[1]) {
                        hours = hours + 12;
                    }
                }
                return hours;
            }

            // Input elements
            var inputs = element.find('input');
            var hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1);

            // Respond on mousewheel spin
            var mousewheel = (angular.isDefined(attrs.mousewheel)) ? scope.$eval(attrs.mousewheel) : timepickerConfig.mousewheel;
            if (mousewheel) {

                var isScrollingUp = function (e) {
                    if (e.originalEvent) {
                        e = e.originalEvent;
                    }
                    //pick correct delta variable depending on event
                    var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;
                    return (e.detail || delta > 0);
                };

                hoursInputEl.bind('mousewheel wheel', function (e) {
                    scope.$apply((isScrollingUp(e)) ? scope.incrementHours() : scope.decrementHours());
                    e.preventDefault();
                });

                minutesInputEl.bind('mousewheel wheel', function (e) {
                    scope.$apply((isScrollingUp(e)) ? scope.incrementMinutes() : scope.decrementMinutes());
                    e.preventDefault();
                });
            }

            var keyboardChange = false;
            scope.readonlyInput = (angular.isDefined(attrs.readonlyInput)) ? scope.$eval(attrs.readonlyInput) : timepickerConfig.readonlyInput;
            if (!scope.readonlyInput) {
                scope.updateHours = function () {
                    var hours = getScopeHours();

                    if (angular.isDefined(hours)) {
                        keyboardChange = 'h';
                        if (scope.model === null) {
                            scope.model = new Date(selected);
                        }
                        scope.model.setHours(hours);
                    } else {
                        scope.model = null;
                        scope.validHours = false;
                    }
                };

                hoursInputEl.bind('blur', function (e) {
                    if (scope.validHours && scope.hours < 10) {
                        scope.$apply(function () {
                            scope.hours = padFilter(scope.hours);
                        });
                    }
                });

                scope.updateMinutes = function () {
                    var minutes = parseInt(scope.minutes, 10);
                    if (minutes >= 0 && minutes < 60) {
                        keyboardChange = 'm';
                        if (scope.model === null) {
                            scope.model = new Date(selected);
                        }
                        scope.model.setMinutes(minutes);
                    } else {
                        scope.model = null;
                        scope.validMinutes = false;
                    }
                };

                minutesInputEl.bind('blur', function (e) {
                    if (scope.validMinutes && scope.minutes < 10) {
                        scope.$apply(function () {
                            scope.minutes = padFilter(scope.minutes);
                        });
                    }
                });
            } else {
                scope.updateHours = angular.noop;
                scope.updateMinutes = angular.noop;
            }

            scope.$watch(function getModelTimestamp() {
                return +scope.model;
            }, function (timestamp) {
                if (!isNaN(timestamp) && timestamp > 0) {
                    selected = new Date(timestamp);
                    refreshTemplate();
                }
            });

            function refreshTemplate() {
                var hours = selected.getHours();
                if (scope.showMeridian) {
                    // Convert 24 to 12 hour system
                    hours = (hours === 0 || hours === 12) ? 12 : hours % 12;
                }
                scope.hours = (keyboardChange === 'h') ? hours : padFilter(hours);
                scope.validHours = true;

                var minutes = selected.getMinutes();
                scope.minutes = (keyboardChange === 'm') ? minutes : padFilter(minutes);
                scope.validMinutes = true;

                scope.meridian = (scope.showMeridian) ? ((selected.getHours() < 12) ? meridians[0] : meridians[1]) : '';

                keyboardChange = false;
            }

            function addMinutes(minutes) {
                var dt = new Date(selected.getTime() + minutes * 60000);
                selected.setHours(dt.getHours());
                selected.setMinutes(dt.getMinutes());
                scope.model = new Date(selected);
            }

            scope.incrementHours = function () {
                addMinutes(hourStep * 60);
            };
            scope.decrementHours = function () {
                addMinutes(-hourStep * 60);
            };
            scope.incrementMinutes = function () {
                addMinutes(minuteStep);
            };
            scope.decrementMinutes = function () {
                addMinutes(-minuteStep);
            };
            scope.toggleMeridian = function () {
                addMinutes(12 * 60 * ((selected.getHours() < 12) ? 1 : -1));
            };
        }
    };
}]);

angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position'])

/**
 * A helper service that can parse typeahead's syntax (string provided by users)
 * Extracted to a separate service for ease of unit testing
 */
  .factory('typeaheadParser', ['$parse', function ($parse) {

      //                      00000111000000000000022200000000000000003333333333333330000000000044000
      var TYPEAHEAD_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+(.*)$/;

      return {
          parse: function (input) {

              var match = input.match(TYPEAHEAD_REGEXP), modelMapper, viewMapper, source;
              if (!match) {
                  throw new Error(
                    "Expected typeahead specification in form of '_modelValue_ (as _label_)? for _item_ in _collection_'" +
                      " but got '" + input + "'.");
              }

              return {
                  itemName: match[3],
                  source: $parse(match[4]),
                  viewMapper: $parse(match[2] || match[1]),
                  modelMapper: $parse(match[1])
              };
          }
      };
  }])

  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$position', 'typeaheadParser', function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {

      var HOT_KEYS = [9, 13, 27, 38, 40];

      return {
          require: 'ngModel',
          link: function (originalScope, element, attrs, modelCtrl) {

              //SUPPORTED ATTRIBUTES (OPTIONS)

              //minimal no of characters that needs to be entered before typeahead kicks-in
              var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;

              //minimal wait time after last character typed before typehead kicks-in
              var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

              //should it restrict model values to the ones selected from the popup only?
              var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;

              //binding to a variable that indicates if matches are being retrieved asynchronously
              var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

              //a callback executed when a match is selected
              var onSelectCallback = $parse(attrs.typeaheadOnSelect);

              var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

              //INTERNAL VARIABLES

              //model setter executed upon match selection
              var $setModelValue = $parse(attrs.ngModel).assign;

              //expressions used by typeahead
              var parserResult = typeaheadParser.parse(attrs.typeahead);


              //pop-up element used to display matches
              var popUpEl = angular.element('<typeahead-popup></typeahead-popup>');
              popUpEl.attr({
                  matches: 'matches',
                  active: 'activeIdx',
                  select: 'select(activeIdx)',
                  query: 'query',
                  position: 'position'
              });
              //custom item template
              if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
                  popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
              }

              //create a child scope for the typeahead directive so we are not polluting original scope
              //with typeahead-specific data (matches, query etc.)
              var scope = originalScope.$new();
              originalScope.$on('$destroy', function () {
                  scope.$destroy();
              });

              var resetMatches = function () {
                  scope.matches = [];
                  scope.activeIdx = -1;
              };

              var getMatchesAsync = function (inputValue) {

                  var locals = { $viewValue: inputValue };
                  isLoadingSetter(originalScope, true);
                  $q.when(parserResult.source(scope, locals)).then(function (matches) {

                      //it might happen that several async queries were in progress if a user were typing fast
                      //but we are interested only in responses that correspond to the current view value
                      if (inputValue === modelCtrl.$viewValue) {
                          if (matches.length > 0) {

                              scope.activeIdx = 0;
                              scope.matches.length = 0;

                              //transform labels
                              for (var i = 0; i < matches.length; i++) {
                                  locals[parserResult.itemName] = matches[i];
                                  scope.matches.push({
                                      label: parserResult.viewMapper(scope, locals),
                                      model: matches[i]
                                  });
                              }

                              scope.query = inputValue;
                              //position pop-up with matches - we need to re-calculate its position each time we are opening a window
                              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
                              //due to other elements being rendered
                              scope.position = $position.position(element);
                              scope.position.top = scope.position.top + element.prop('offsetHeight');

                          } else {
                              resetMatches();
                          }
                          isLoadingSetter(originalScope, false);
                      }
                  }, function () {
                      resetMatches();
                      isLoadingSetter(originalScope, false);
                  });
              };

              resetMatches();

              //we need to propagate user's query so we can higlight matches
              scope.query = undefined;

              //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later 
              var timeoutPromise;

              //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
              //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
              modelCtrl.$parsers.push(function (inputValue) {

                  resetMatches();
                  if (inputValue && inputValue.length >= minSearch) {
                      if (waitTime > 0) {
                          if (timeoutPromise) {
                              $timeout.cancel(timeoutPromise);//cancel previous timeout
                          }
                          timeoutPromise = $timeout(function () {
                              getMatchesAsync(inputValue);
                          }, waitTime);
                      } else {
                          getMatchesAsync(inputValue);
                      }
                  }

                  return isEditable ? inputValue : undefined;
              });

              modelCtrl.$formatters.push(function (modelValue) {

                  var candidateViewValue, emptyViewValue;
                  var locals = {};

                  if (inputFormatter) {

                      locals['$model'] = modelValue;
                      return inputFormatter(originalScope, locals);

                  } else {
                      locals[parserResult.itemName] = modelValue;

                      //it might happen that we don't have enough info to properly render input value
                      //we need to check for this situation and simply return model value if we can't apply custom formatting
                      candidateViewValue = parserResult.viewMapper(originalScope, locals);
                      emptyViewValue = parserResult.viewMapper(originalScope, {});

                      return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
                  }
              });

              scope.select = function (activeIdx) {
                  //called from within the $digest() cycle
                  var locals = {};
                  var model, item;

                  locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
                  model = parserResult.modelMapper(originalScope, locals);
                  $setModelValue(originalScope, model);

                  onSelectCallback(originalScope, {
                      $item: item,
                      $model: model,
                      $label: parserResult.viewMapper(originalScope, locals)
                  });

                  //return focus to the input element if a mach was selected via a mouse click event
                  resetMatches();
                  element[0].focus();
              };

              //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
              element.bind('keydown', function (evt) {

                  //typeahead is open and an "interesting" key was pressed
                  if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
                      return;
                  }

                  evt.preventDefault();

                  if (evt.which === 40) {
                      scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
                      scope.$digest();

                  } else if (evt.which === 38) {
                      scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1;
                      scope.$digest();

                  } else if (evt.which === 13 || evt.which === 9) {
                      scope.$apply(function () {
                          scope.select(scope.activeIdx);
                      });

                  } else if (evt.which === 27) {
                      evt.stopPropagation();

                      resetMatches();
                      scope.$digest();
                  }
              });

              $document.bind('click', function () {
                  resetMatches();
                  scope.$digest();
              });

              element.after($compile(popUpEl)(scope));
          }
      };

  }])

  .directive('typeaheadPopup', function () {
      return {
          restrict: 'E',
          scope: {
              matches: '=',
              query: '=',
              active: '=',
              position: '=',
              select: '&'
          },
          replace: true,
          templateUrl: 'template/typeahead/typeahead-popup.html',
          link: function (scope, element, attrs) {

              scope.templateUrl = attrs.templateUrl;

              scope.isOpen = function () {
                  return scope.matches.length > 0;
              };

              scope.isActive = function (matchIdx) {
                  return scope.active == matchIdx;
              };

              scope.selectActive = function (matchIdx) {
                  scope.active = matchIdx;
              };

              scope.selectMatch = function (activeIdx) {
                  scope.select({ activeIdx: activeIdx });
              };
          }
      };
  })

  .directive('typeaheadMatch', ['$http', '$templateCache', '$compile', '$parse', function ($http, $templateCache, $compile, $parse) {
      return {
          restrict: 'E',
          scope: {
              index: '=',
              match: '=',
              query: '='
          },
          link: function (scope, element, attrs) {
              var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
              $http.get(tplUrl, { cache: $templateCache }).success(function (tplContent) {
                  element.replaceWith($compile(tplContent.trim())(scope));
              });
          }
      };
  }])

  .filter('typeaheadHighlight', function () {

      function escapeRegexp(queryToEscape) {
          return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
      }

      return function (matchItem, query) {
          return query ? matchItem.replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : query;
      };
  });
angular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/accordion/accordion-group.html",
      "<div class=\"accordion-group\">\n" +
      "  <div class=\"accordion-heading\" ><a class=\"accordion-toggle\" ng-click=\"isOpen = !isOpen\" accordion-transclude=\"heading\">{{heading}}</a></div>\n" +
      "  <div class=\"accordion-body\" collapse=\"!isOpen\">\n" +
      "    <div class=\"accordion-inner\" ng-transclude></div>  </div>\n" +
      "</div>");
}]);

angular.module("template/accordion/accordion.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/accordion/accordion.html",
      "<div class=\"accordion\" ng-transclude></div>");
}]);

angular.module("template/alert/alert.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/alert/alert.html",
      "<div class='alert' ng-class='type && \"alert-\" + type'>\n" +
      "    <button ng-show='closeable' type='button' class='close' ng-click='close()'>&times;</button>\n" +
      "    <div ng-transclude></div>\n" +
      "</div>\n" +
      "");
}]);

angular.module("template/carousel/carousel.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/carousel/carousel.html",
      "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\">\n" +
      "    <ol class=\"carousel-indicators\" ng-show=\"slides().length > 1\">\n" +
      "        <li ng-repeat=\"slide in slides()\" ng-class=\"{active: isActive(slide)}\" ng-click=\"select(slide)\"></li>\n" +
      "    </ol>\n" +
      "    <div class=\"carousel-inner\" ng-transclude></div>\n" +
      "    <a ng-click=\"prev()\" class=\"carousel-control left\" ng-show=\"slides().length > 1\">&lsaquo;</a>\n" +
      "    <a ng-click=\"next()\" class=\"carousel-control right\" ng-show=\"slides().length > 1\">&rsaquo;</a>\n" +
      "</div>\n" +
      "");
}]);

angular.module("template/carousel/slide.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/carousel/slide.html",
      "<div ng-class=\"{\n" +
      "    'active': leaving || (active && !entering),\n" +
      "    'prev': (next || active) && direction=='prev',\n" +
      "    'next': (next || active) && direction=='next',\n" +
      "    'right': direction=='prev',\n" +
      "    'left': direction=='next'\n" +
      "  }\" class=\"item\" ng-transclude></div>\n" +
      "");
}]);

angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/datepicker/datepicker.html",
      "<table>\n" +
      "  <thead>\n" +
      "    <tr class=\"text-center\">\n" +
      "      <th><button type=\"button\" class=\"btn pull-left\" ng-click=\"move(-1)\"><i class=\"icon-chevron-left\"></i></button></th>\n" +
      "      <th colspan=\"{{rows[0].length - 2 + showWeekNumbers}}\"><button type=\"button\" class=\"btn btn-block\" ng-click=\"toggleMode()\"><strong>{{title}}</strong></button></th>\n" +
      "      <th><button type=\"button\" class=\"btn pull-right\" ng-click=\"move(1)\"><i class=\"icon-chevron-right\"></i></button></th>\n" +
      "    </tr>\n" +
      "    <tr class=\"text-center\" ng-show=\"labels.length > 0\">\n" +
      "      <th ng-show=\"showWeekNumbers\">#</th>\n" +
      "      <th ng-repeat=\"label in labels\">{{label}}</th>\n" +
      "    </tr>\n" +
      "  </thead>\n" +
      "  <tbody>\n" +
      "    <tr ng-repeat=\"row in rows\">\n" +
      "      <td ng-show=\"showWeekNumbers\" class=\"text-center\"><em>{{ getWeekNumber(row) }}</em></td>\n" +
      "      <td ng-repeat=\"dt in row\" class=\"text-center\">\n" +
      "        <button type=\"button\" style=\"width:100%;\" class=\"btn\" ng-class=\"{'btn-info': dt.selected}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\"><span ng-class=\"{muted: dt.secondary}\">{{dt.label}}</span></button>\n" +
      "      </td>\n" +
      "    </tr>\n" +
      "  </tbody>\n" +
      "</table>\n" +
      "");
}]);

angular.module("template/datepicker/popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/datepicker/popup.html",
      "<ul class=\"dropdown-menu\" ng-style=\"{display: (isOpen && 'block') || 'none', top: position.top+'px', left: position.left+'px'}\" class=\"dropdown-menu\">\n" +
      "	<li ng-transclude></li>\n" +
      "	<li class=\"divider\"></li>\n" +
      "	<li style=\"padding: 9px;\">\n" +
      "		<span class=\"btn-group\">\n" +
      "			<button class=\"btn btn-small btn-inverse\" ng-click=\"today()\">Today</button>\n" +
      "			<button class=\"btn btn-small btn-info\" ng-click=\"showWeeks = ! showWeeks\" ng-class=\"{active: showWeeks}\">Weeks</button>\n" +
      "			<button class=\"btn btn-small btn-danger\" ng-click=\"clear()\">Clear</button>\n" +
      "		</span>\n" +
      "		<button class=\"btn btn-small btn-success pull-right\" ng-click=\"isOpen = false\">Close</button>\n" +
      "	</li>\n" +
      "</ul>");
}]);

angular.module("template/dialog/message.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/dialog/message.html",
      "<div class=\"modal-header\">\n" +
      "	<h3>{{ title }}</h3>\n" +
      "</div>\n" +
      "<div class=\"modal-body\">\n" +
      "	<p>{{ message }}</p>\n" +
      "</div>\n" +
      "<div class=\"modal-footer\">\n" +
      "	<button ng-repeat=\"btn in buttons\" ng-click=\"close(btn.result)\" class=\"btn\" ng-class=\"btn.cssClass\">{{ btn.label }}</button>\n" +
      "</div>\n" +
      "");
}]);

angular.module("template/modal/backdrop.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/modal/backdrop.html",
      "<div class=\"modal-backdrop fade in\"></div>");
}]);

angular.module("template/modal/window.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/modal/window.html",
      "<div class=\"modal in\" ng-transclude></div>");
}]);

angular.module("template/pagination/pager.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/pagination/pager.html",
      "<div class=\"pager\">\n" +
      "  <ul>\n" +
      "    <li ng-repeat=\"page in pages\" ng-class=\"{disabled: page.disabled, previous: page.previous, next: page.next}\"><a ng-click=\"selectPage(page.number)\">{{page.text}}</a></li>\n" +
      "  </ul>\n" +
      "</div>\n" +
      "");
}]);

angular.module("template/pagination/pagination.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/pagination/pagination.html",
      "<div class=\"pagination\"><ul>\n" +
      "  <li ng-repeat=\"page in pages\" ng-class=\"{active: page.active, disabled: page.disabled}\"><a ng-click=\"selectPage(page.number)\">{{page.text}}</a></li>\n" +
      "  </ul>\n" +
      "</div>\n" +
      "");
}]);

angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html",
      "<div class=\"tooltip {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
      "  <div class=\"tooltip-arrow\"></div>\n" +
      "  <div class=\"tooltip-inner\" ng-bind-html-unsafe=\"content\"></div>\n" +
      "</div>\n" +
      "");
}]);

angular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/tooltip/tooltip-popup.html",
      "<div class=\"tooltip {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
      "  <div class=\"tooltip-arrow\"></div>\n" +
      "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
      "</div>\n" +
      "");
}]);

angular.module("template/popover/popover.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/popover/popover.html",
      "<div class=\"popover {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
      "  <div class=\"arrow\"></div>\n" +
      "\n" +
      "  <div class=\"popover-inner\">\n" +
      "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-show=\"title\"></h3>\n" +
      "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
      "  </div>\n" +
      "</div>\n" +
      "");
}]);

angular.module("template/progressbar/bar.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/progressbar/bar.html",
      "<div class=\"bar\" ng-class='type && \"bar-\" + type'></div>");
}]);

angular.module("template/progressbar/progress.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/progressbar/progress.html",
      "<div class=\"progress\"><progressbar ng-repeat=\"bar in bars\" width=\"bar.to\" old=\"bar.from\" animate=\"bar.animate\" type=\"bar.type\"></progressbar></div>");
}]);

angular.module("template/rating/rating.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/rating/rating.html",
      "<span ng-mouseleave=\"reset()\">\n" +
      "	<i ng-repeat=\"number in range\" ng-mouseenter=\"enter(number)\" ng-click=\"rate(number)\" ng-class=\"{'icon-star': number <= val, 'icon-star-empty': number > val}\"></i>\n" +
      "</span>");
}]);

angular.module("template/tabs/pane.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/tabs/pane.html",
      "<div class=\"tab-pane\" ng-class=\"{active: selected}\" ng-show=\"selected\" ng-transclude></div>\n" +
      "");
}]);

angular.module("template/tabs/tab.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/tabs/tab.html",
      "<li ng-class=\"{active: active, disabled: disabled}\">\n" +
      "  <a ng-click=\"select()\" tab-heading-transclude>{{heading}}</a>\n" +
      "</li>\n" +
      "");
}]);

angular.module("template/tabs/tabs.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/tabs/tabs.html",
      "<div class=\"tabbable\">\n" +
      "  <ul class=\"nav nav-tabs\">\n" +
      "    <li ng-repeat=\"pane in panes\" ng-class=\"{active:pane.selected}\">\n" +
      "      <a ng-click=\"select(pane)\">{{pane.heading}}</a>\n" +
      "    </li>\n" +
      "  </ul>\n" +
      "  <div class=\"tab-content\" ng-transclude></div>\n" +
      "</div>\n" +
      "");
}]);

angular.module("template/tabs/tabset-titles.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/tabs/tabset-titles.html",
      "<ul class=\"nav {{type && 'nav-' + type}}\" ng-class=\"{'nav-stacked': vertical}\">\n" +
      "</ul>\n" +
      "");
}]);

angular.module("template/tabs/tabset.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/tabs/tabset.html",
      "\n" +
      "<div class=\"tabbable\" ng-class=\"{'tabs-right': direction == 'right', 'tabs-left': direction == 'left', 'tabs-below': direction == 'below'}\">\n" +
      "  <div tabset-titles=\"tabsAbove\"></div>\n" +
      "  <div class=\"tab-content\">\n" +
      "    <div class=\"tab-pane\" \n" +
      "         ng-repeat=\"tab in tabs\" \n" +
      "         ng-class=\"{active: tab.active}\"\n" +
      "         tab-content-transclude=\"tab\">\n" +
      "    </div>\n" +
      "  </div>\n" +
      "  <div tabset-titles=\"!tabsAbove\"></div>\n" +
      "</div>\n" +
      "");
}]);

angular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/timepicker/timepicker.html",
      "<table class=\"form-inline\">\n" +
      "	<tr class=\"text-center\">\n" +
      "		<td><a ng-click=\"incrementHours()\" class=\"btn btn-link\"><i class=\"icon-chevron-up\"></i></a></td>\n" +
      "		<td>&nbsp;</td>\n" +
      "		<td><a ng-click=\"incrementMinutes()\" class=\"btn btn-link\"><i class=\"icon-chevron-up\"></i></a></td>\n" +
      "		<td ng-show=\"showMeridian\"></td>\n" +
      "	</tr>\n" +
      "	<tr>\n" +
      "		<td class=\"control-group\" ng-class=\"{'error': !validHours}\"><input type=\"text\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"span1 text-center\" ng-mousewheel=\"incrementHours()\" ng-readonly=\"readonlyInput\" maxlength=\"2\" /></td>\n" +
      "		<td>:</td>\n" +
      "		<td class=\"control-group\" ng-class=\"{'error': !validMinutes}\"><input type=\"text\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"span1 text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\"></td>\n" +
      "		<td ng-show=\"showMeridian\"><button ng-click=\"toggleMeridian()\" class=\"btn text-center\">{{meridian}}</button></td>\n" +
      "	</tr>\n" +
      "	<tr class=\"text-center\">\n" +
      "		<td><a ng-click=\"decrementHours()\" class=\"btn btn-link\"><i class=\"icon-chevron-down\"></i></a></td>\n" +
      "		<td>&nbsp;</td>\n" +
      "		<td><a ng-click=\"decrementMinutes()\" class=\"btn btn-link\"><i class=\"icon-chevron-down\"></i></a></td>\n" +
      "		<td ng-show=\"showMeridian\"></td>\n" +
      "	</tr>\n" +
      "</table>");
}]);

angular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/typeahead/typeahead-match.html",
      "<a tabindex=\"-1\" ng-bind-html-unsafe=\"match.label | typeaheadHighlight:query\"></a>");
}]);

angular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/typeahead/typeahead-popup.html",
      "<ul class=\"typeahead dropdown-menu\" ng-style=\"{display: isOpen()&&'block' || 'none', top: position.top+'px', left: position.left+'px'}\">\n" +
      "    <li ng-repeat=\"match in matches\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index)\">\n" +
      "        <typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></typeahead-match>\n" +
      "    </li>\n" +
      "</ul>");
}]);

angular.module("template/typeahead/typeahead.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/typeahead/typeahead.html",
      "<ul class=\"typeahead dropdown-menu\" ng-style=\"{display: isOpen()&&'block' || 'none', top: position.top+'px', left: position.left+'px'}\">\n" +
      "    <li ng-repeat=\"match in matches\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\">\n" +
      "        <a tabindex=\"-1\" ng-click=\"selectMatch($index)\" ng-bind-html-unsafe=\"match.label | typeaheadHighlight:query\"></a>\n" +
      "    </li>\n" +
      "</ul>");
}]);